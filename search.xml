<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>信号与系统/信号与系统-时域分析</title>
      <link href="/2020/03/23/xin-hao-yu-xi-tong/xin-hao-yu-xi-tong-shi-yu-fen-xi/"/>
      <url>/2020/03/23/xin-hao-yu-xi-tong/xin-hao-yu-xi-tong-shi-yu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、连续系统的时域分析"><a href="#一、连续系统的时域分析" class="headerlink" title="一、连续系统的时域分析"></a>一、连续系统的时域分析</h1><p>(这入门研究的都是LTI系统,后面就不强调了)</p><h2 id="1-连续系统的响应"><a href="#1-连续系统的响应" class="headerlink" title="1. 连续系统的响应"></a><font size="5">1. 连续系统的响应</font></h2><h3 id="1-微分方程的经典解"><a href="#1-微分方程的经典解" class="headerlink" title="(1)微分方程的经典解"></a>(1)微分方程的经典解</h3><p>激励是$f(t)$,响应是$y(t)$</p><p>$\sum_{j=0}^na_jy^{(j)}(t)=\sum_{i=0}^mb_if^{(i)}(t)$</p><p>其中a,b都是常数.</p><p>这样的方程由齐次解$y_h(t)$和特解$y_p(t)$组成.</p><p>即:$y(t)=y_h(t)+y_p(t)$</p><p><strong>重点(一定要背过):</strong></p><p><img src="0323-picture1.png" alt="不同特征根对应的齐次解表格,第一行错了,少写了待定系数C"></p><p><img src="0323-picture2.png" alt="不同激励对应的特解表格"></p><p><strong>特点:</strong> 齐次解的函数形式取决于系统本身,与$f(t)$无关,称为系统的<strong>自由响应/固有响应</strong>,特征方程的根$\lambda_i$称为系统的<strong>固有频率</strong>,它决定了系统自由响应的形式,但是<strong>齐次解的系数$C_i$是和激励$f(t)$有关的.</strong> 特解的形式完全由激励信号确定,称为<strong>强迫响应</strong>.</p><p><strong>eg.</strong></p><p>某系统的微分方程为:$y^{``}(t)+5y^`(t)+6y(t)=f(t)$</p><p>求:激励$f(t)=10cost,t&gt;=0;y(0)=2,y^`(0)=0$时的全响应.</p><p>解:</p><p>特征方程:$\lambda^2+5\lambda+6=0$</p><p>求得特征根:$\lambda_1=-2,\lambda_2=-3$</p><p>根据表格,对应的齐次解的形式是:$y_h(t)=C_1e^{-2t}+C_2e^{-3t}$</p><p>(这是二个单根,对应的是$(C_1e^{\lambda_1 t}+C_2e^{\lambda_2 t}$)</p><p>根据表格,对应的特解形式:$y_p(t)=Pcost+Qsint$</p><p>$y_p^{``}(t)+5y_p^`(t)+6y_p(t)=f(t)$</p><p>带入$f(t),y_p(t)$得:</p><p>$(-P+5Q+6P)cost+(-Q-5P+6Q)sint=10cost$</p><p>因为上式对所有t&gt;=0成立,所以带入$t=\frac{\pi}{2},t=\pi$</p><p>解得P=Q=1</p><p>所以,$y_p(t)=cost+sint$</p><p>所以全响应:$y(t)=y_h(t)+y_p(t)=C_1e^{-2t}+C_2e^{-3t}+cost+sint$</p><p>带入已知条件:$y(0)=2,y^`(0)=0$</p><p>解得$C_1=2,C_2=-1$</p><p>结果:$y(t)=2e^{-2t}-e^{-3t}+\sqrt2cos(t-\frac{\pi}{4}),t&gt;=0$</p><p><strong>根据响应的形式,也可以分为<font size="4" color="red">瞬态响应和稳态响应</font>,前者随着时间越来越大,会消失,后者不会消失</strong></p><h3 id="2-0时刻解微分方程"><a href="#2-0时刻解微分方程" class="headerlink" title="(2)0时刻解微分方程"></a>(2)0时刻解微分方程</h3><p><strong>经典法不适合0时刻接入激励的情况</strong></p><p>因为t=0_时,激励没有接入,所以$y=y_{zi}$(零输入响应),</p><p>从t=0+时刻开始,才有$y=y_{zi}+y_{zs}$</p><p>通常我们的已知情况是激励接入前,即t=0_时刻.</p><p><strong>eg.</strong></p><p>已知LTI系统的微分方程:</p><p>$y^{<code>}(t)+2y^`(t)+y(t)=f^{</code>}(t)+2f(t)$</p><p>$y(0_{-})=1,y^`({0_{-}})=-1,f(t)=\delta(t)$,</p><p>求$y(0_{+})和y^`({0{+}})$.</p><p><strong>解:</strong></p><p>代入$f(t)=\delta(t)$</p><p>$y^{<code>}(t)+2y^`(t)+y(t)=\delta^{</code>}(t)+2\delta(t)$</p><p>观察发现,右边有$\delta^{<code>}(t)$,一定是$y^{</code>}(t)$包含的.</p><p>设:$y^{<code>}(t)=a\delta^{</code>}(t)+b\delta^`(t)+c\delta(t)+r_0(t)$,其中:$a,b,c,r_0(t)$都是常数.</p><p>则$y^<code>(t)=a\delta^</code>(t)+b\delta(t)+r_1,其中r_1=c\xi(t)+\int_{-\infty}^tr_0(t)$.</p><p>$y(t)=a\delta(t)+r_2,其中r_2=b\xi(t)+\int_{-\infty}^tr_1(t)$</p><p>代入原方程,对应$\delta(t)$的系数,得到:</p><p>$a=1,b+2a=0,c+2b+a=2$,</p><p>解得$a=1,b=-2,c=5$</p><p>$y(0_{+})-y(0_{-})=\int_{0_{-}}^{0_{+}}y^<code>(t)dt=\int_{0_{-}}^{0_{+}}\delta^</code>(t)dt-2\int_{0_{-}}^{0_{+}}\delta(t)dt+0$</p><p>因为$\int_{0_{-}}^{0_{+}}\delta^`(t)dt=0,\int_{0_{-}}^{0_{+}}\delta(t)dt=1$</p><p>所以$y(0_{+})-y(0_{-})=-2$</p><p>得$y(0_{+})=-1$</p><p>$y^<code>(0_{+})-y^</code>(0_{-})=\int_{0_{-}}^{0_{+}}y^{<code>}(t)dt=\int_{0_{-}}^{0_{+}}\delta^{</code>}(t)dt-2\int_{0_{-}}^{0_{+}}\delta^`(t)dt+5\int_{0_{-}}^{0_{+}}\delta(t)dt+0$</p><p>因为$\int_{0_{-}}^{0_{+}}\delta^`(t)dt=0,\int_{0_{-}}^{0_{+}}\delta^{``}(t)dt=0,\int_{0_{-}}^{0_{+}}\delta(t)dt=1$</p><p>所以$y^<code>(0_{+})-y^</code>(0_{-})=5$</p><p>得$y^`(0_{+})=4$</p><p>答案:$y^`(0_{+})=4,y(0_{+})=-1$</p><p><font color="red"><strong>注意(记住):$\int_{0_{-}}^{0_{+}}\delta^`(t)dt=0,\int_{0_{-}}^{0_{+}}\delta^{``}(t)dt=0,\int_{0_{-}}^{0_{+}}\delta(t)dt=1$</strong></font></p><h3 id="3-零输入响应"><a href="#3-零输入响应" class="headerlink" title="(3)零输入响应"></a>(3)零输入响应</h3><p><strong>注意<font color="blue" size="4">:零输入响应不会突变</font></strong></p><p><strong>eg.</strong> </p><p>已知某系统的微分方程:<br>$y^{``}(t)+5y^<code>(t)+4y(t)=2f^</code>(t)-4f(t)$</p><p>初始状态:$y^{`}(0_{-})=5,y({0_{-}})=1$</p><p>求系统的零输入响应</p><p><strong>解:</strong> </p><p>$y_{zi}(0_{+})=y_{zi}(0_{-})=y(0_{-})=1;y^<code>_{zi}(0_{+})=y^</code><em>{zi}(0</em>{-})=y(0_{-})$</p><p>$y^{``}<em>{zi}(t)+5y^`</em>{zi}(t)+4y_{zi}(t)=0$</p><p>其特征方程为:$\lambda^2+5\lambda+4=0$</p><p>特征根:$\lambda_1=-1,\lambda_2=-4$</p><p>根据表格,得到:$y_{zi}(t)=C_1e^{-1t}+C_2e^{-4t}$</p><p>带入$y_{zi}(0_{+})=y_{zi}(0_{-})=y(0_{-})=1;y^<code>_{zi}(0_{+})=y^</code><em>{zi}(0</em>{-})=y(0_{-})$,得到:</p><p>$C_1+C_2=1,-C_1-4C_2=5$</p><p>结果:$y_{zi}(t)=3e^{-1}-2e^{-4t}$</p><h3 id="4-零状态响应"><a href="#4-零状态响应" class="headerlink" title="(4)零状态响应"></a>(4)零状态响应</h3><p><strong>注意<font color="blue" size="4">:零状态响应是在0+点突变的,在0_点永远是零</font></strong></p><p><strong>eg1.</strong></p><p>已知某系统的零状态响应为:</p><p>$y^{``}<em>{zs}(t)+5y^`</em>{zs}(t)+4y_{zs}(t)=2f^`(t)-4f(t)$</p><p>初始状态:$y_{zs}(0_{-})=y^`<em>{zs}(0</em>{-})=0$</p><p>输入$f(t)=\xi(t)$</p><p>得:<br>$y^{``}<em>{zs}(t)+5y^`</em>{zs}(t)+4y_{zs}(t)=2\xi^`(t)-4\xi(t)$</p><p>观察:</p><p>设$y^{``}_{zs}(t)=a\delta(t)+r_0(t)$</p><p>则:$y^{<code>}_{zs}(t)=r_1(t),y^{</code>}_{zs}(t)=r_2(t)$</p><p>a=2</p><p>$y_{zs}(0_{+})-y_{zs}(0_{-})=\int_{0-}^{0+}y^`(t)dt=0$</p><p>$y^<code>_{zs}(0_{+})-y^</code><em>{zs}(0</em>{-})=\int_{0-}^{0+}y^{``}(t)dt=\int_{0-}^{0+}a\delta(t)dt+\int_{0-}^{0+}r_0(t)dt=a=2$</p><p>所以,$y_{zs}(0_{+})=0,y^`_{zs}(0+)=2$</p><p>对于t&gt;0时,</p><p>原方程等价为:</p><p>$y^{``}<em>{zs}(t)+5y^`</em>{zs}(t)+4y_{zs}(t)=-4$</p><p>其特征方程为:$\lambda^2+5\lambda+4=0$</p><p>解得:$\lambda_1=-1,\lambda_2=-4$</p><p>根据表格,对应得齐次解是:</p><p>$y_{zs}(t)=C_1e^{-t}+C_2e^{-4t}$</p><p>带入$y_{zs}(0_{+})=0,y^`_{zs}(0+)=2$</p><p>解得$C_1=2,C_2=-1$</p><p>答案:$y_{zs}(t)=2e^{-t}-e^{-4t},t&gt;=0$</p><p><strong>eg2.</strong></p><p>已知某LTI系统的微分方程:</p><p>$y^<code>(t)+2y(t)=f^{``}(t)+f^</code>(t)+2f(t)$</p><p>加入激励$f(t)=\xi(t)$</p><p>求零状态响应.</p><p><strong>解:</strong></p><p>设$y_1是由f(t)$引起的零状态响应</p><p>则$y_1^`(t)+2y_1(t)=\xi(t),且y_1(0_{-})=0$</p><p>$y_{zs}(t)=y_1^{``}(t)+y_1~(t)+2y_1(t)$</p><p>$y_1(t)$的特征方程$\lambda+2=0$</p><p>又因为激励是$e^0$,所以特解是常数.</p><p>设$y_1(t)=Ce^{-2t}+P$</p><p>观察方程,发现$y_1$不含$\delta(t),所以y_1(0_{+})=y_1(0_{-})=0$,</p><p>带入$y_1^`(0_{+})+2y_1(0_{+})=1$</p><p>解得$y_1(t)=0.5(1-e^{-2t}),t&gt;=0$</p><p>由于$y_1(t)$是零状态响应,所以t&lt;0时,$y_1(t)=0$</p><p>所以$y_1=0.5(1-e^{-2t})\xi(t)$</p><p>所以$y_{zs}(t)=y_1^{``}(t)+y_1~(t)+2y_1(t)=\delta(t)+(1-2e^{-2t})\xi(t)$</p><h3 id="5-全响应"><a href="#5-全响应" class="headerlink" title="(5)全响应"></a>(5)全响应</h3><p><strong>全响应=零输入响应+零状态响应</strong></p><p>解题技巧:</p><p>给$0_{-}$时刻的值,就先求零状态响应,</p><p>给了$0_{+}$时刻的值,就先求零输入响应.</p><h2 id="2-冲激响应和阶跃响应"><a href="#2-冲激响应和阶跃响应" class="headerlink" title="2. 冲激响应和阶跃响应"></a><font size="5">2. 冲激响应和阶跃响应</font></h2><h3 id="1-冲激响应"><a href="#1-冲激响应" class="headerlink" title="(1)冲激响应"></a>(1)冲激响应</h3><h3 id="2-阶跃响应"><a href="#2-阶跃响应" class="headerlink" title="(2)阶跃响应"></a>(2)阶跃响应</h3><h2 id="3-卷积积分"><a href="#3-卷积积分" class="headerlink" title="3. 卷积积分"></a><font size="5">3. 卷积积分</font></h2><h3 id="1-卷积积分"><a href="#1-卷积积分" class="headerlink" title="(1)卷积积分"></a>(1)卷积积分</h3><h3 id="2-卷积的图示"><a href="#2-卷积的图示" class="headerlink" title="(2)卷积的图示"></a>(2)卷积的图示</h3><h2 id="4-卷积积分的性质"><a href="#4-卷积积分的性质" class="headerlink" title="4. 卷积积分的性质"></a><font size="5">4. 卷积积分的性质</font></h2><h3 id="1-卷积的代数运算"><a href="#1-卷积的代数运算" class="headerlink" title="(1)卷积的代数运算"></a>(1)卷积的代数运算</h3><h3 id="2-普通函数和冲激函数的卷积"><a href="#2-普通函数和冲激函数的卷积" class="headerlink" title="(2)普通函数和冲激函数的卷积"></a>(2)普通函数和冲激函数的卷积</h3><h3 id="3-卷积的微分和积分"><a href="#3-卷积的微分和积分" class="headerlink" title="(3)卷积的微分和积分"></a>(3)卷积的微分和积分</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信号与系统-基础知识篇</title>
      <link href="/2020/03/22/xin-hao-yu-xi-tong/xin-hao-yu-xi-tong-shi-ji-chu-zhi-shi/"/>
      <url>/2020/03/22/xin-hao-yu-xi-tong/xin-hao-yu-xi-tong-shi-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基本知识"><a href="#一、基本知识" class="headerlink" title="一、基本知识"></a>一、基本知识</h1><h2 id="1-信号的分类"><a href="#1-信号的分类" class="headerlink" title="1.信号的分类"></a><font size="5">1.信号的分类</font></h2><ul><li><p><font size="4"><strong>(1)连续信号和离散信号</strong></font></p><p>  <strong>主要用在时域分析</strong>,略.</p></li><li><p><font size="4"><strong>(2)周期信号和非周期信号</strong></font></p><p> <font color="green">有知识点</font>:判断这个信号是不是周期信号.</p><p> <strong>eg.</strong>$f_1(k)=sin(\frac{\pi}{7}k+\frac{\pi}{6})$</p><p> $\omega_1=\frac{\pi}{7}$,$\frac{2\pi}{\omega_1}=14$</p><p> 14是整数,所以$f_1(k)$是周期序列,周期$N_1$=14</p><p> 如果$\frac{2\pi}{\omega}$结果是无理数,则不是周期信号.</p></li><li><p><font size="4"><strong>(3)实信号和复信号(重要)</strong></font><br> <strong>主要用在频域分析</strong></p><p> <font color="deep red">概念</font>:物理可实现的信号常常是时间的实函数(或序列),其在各个时刻的值为实数.</p><p> <font color="deep red">函数(或序列)值为复数的信号称为复信号,最常用的是复指数信号.</font></p><ul><li><p>连续信号的复指数信号可表示为</p><p>$f(t)=e^{st}$,$-\infin&lt;t&lt;\infty$</p><p>式中复变量s=$\delta+j\omega$,$\delta$是s的实部,记为Re[s],$\omega$是s的虚部,记为Im[s].根据欧拉公式展开.</p><p>$f(t)=e^{(\delta+j\omega)t}=e^{\delta t}cos(\omega t)+je^{\delta t}sin(\omega t)$</p><p>一个复数连续信号可分解为实,虚,两部分,即:</p><p>Re[f(t)]=$e^{\delta t}cos(\omega t)$</p><p>Im[f(t)]=$e^{\delta t}sin(\omega t)$</p><p>二者都是实信号,并且频率相同,振幅随着时间的变化余(正)弦振荡.<strong>s的实部$\delta$表示该信号振幅随时间变化的状况,s的虚部$\omega$表示其振荡角频率</strong>.</p><p>$\delta$&gt;0,表示增幅振荡,$\delta$&lt;0表示衰减振荡,$\delta$=0则表示等幅振荡</p><ul><li>b.离散信号的复指数信号可表示为</li></ul><p>$f(k)=e^{(\alpha+j\beta)k}=e^{\alpha k}e^{j\beta k}$</p><p>令a=$e^{\alpha}$,上式可展开为</p><p>$f(k)=a^kcos(\beta k)+ja^ksin(\beta k)$</p><p>一个复数离散信号可分解为实,虚,两部分,即:</p><p>Re[f(t)]=$a^{k}cos(\beta k)$</p><p>Im[f(t)]=$a^{k}sin(\beta k)$</p><p>显而易见,离散信号的指数上的复数的实部和虚部的意义,和连续信号相同.</p><ul><li><font size="4"><strong>(4)能量信号和功率信号</strong></font></li></ul><p><font color="green">有知识点:</font>判断平均功率以及能量是否有限.</p></li></ul><p>  <strong>为了研究能量或功率的特性,通常我们关注信号(电流/电压)在单位电阻上的能量或功率,也称为归一化能量或功率</strong></p><ul><li><p>连续信号:</p><p>信号f(t)在单位电阻上的瞬时功率为|f(t)|$^2$,(P=$\frac{u^2}{R}$,P=$\frac{i^2}{R}$),</p><p>所以在区间[-a,a]内,能量为:</p><p>$\int^a_{-a} |f(t)|^2dt$</p><p>平均功率为:</p><p>$\frac{1}{2a}\int^a_{-a}|f(t)|^2dt$</p></li></ul><p> <strong>信号的能量定义为在区间(-$\infin$,$\infin$)中,信号f(t)的能量,用字母E表示,即</strong></p><p> E=$lim_{a\to\infty}\int^a_{-a}|f(t)|^2dt$</p><p> P=$lim_{a\to\infty}\frac{1}{2a}\int^a_{-a}|f(t)|^2dt$</p><p> 若信号f(t)的能量有界,则简称其为能量有界信号(此时,P=0).</p><p> 若信号f(t)的功率有界,则简称其为功率信号(,此时,E=$\infty$).</p><p> <strong>只有在有限时间区间不为零的信号是能量信号,这些信号的平均功率为零,因此只能从能量的角度考察</strong></p><p> <strong>直流信号,周期信号,阶跃信号都是功率信号,它们的能量为无限,只能从功率的角度考察</strong></p><p> (有的信号即不是能量信号,也不是功率信号,比如$e^{-t}$)</p><ul><li><p>离散信号:</p><p>对于能量信号和功率信号的定义,和连续信号相同.</p></li></ul></li></ul><h2 id="2-信号的基本运算"><a href="#2-信号的基本运算" class="headerlink" title="2.信号的基本运算"></a><font size="5">2.信号的基本运算</font></h2><ul><li><p><font size="4">(1)加法和乘法</font></p><p>对应位置对应运算即可</p></li><li><p><font size="4">(2)反转和平移</font></p></li><li><p><font size="4">(3)尺度变换</font></p><p><strong>都简单,只有一个要点:推荐运算顺序是<font size="4" color="red">平移-尺度变换-反折</font></strong></p></li></ul><h2 id="3-阶跃函数和冲激函数"><a href="#3-阶跃函数和冲激函数" class="headerlink" title="3.阶跃函数和冲激函数"></a><font size="5">3.阶跃函数和冲激函数</font></h2><ul><li><p><font size="4">阶跃函数和冲激函数</font></p><ul><li><p>阶跃函数是在0点突变成1(t&lt;0,$\xi$(t)=0;t&gt;0,$\xi$(t)=1;<strong>t=0,$\xi$(t)=1/2</strong>)</p></li><li><p>冲激函数是阶跃函数的导数(t=0,$\delta$(t)=1;t!=0,$\delta$(t)=0)</p></li></ul></li><li><p><font size="4">冲激函数的广义函数定义</font> </p><p> 这个不重要,只是一个数学概念</p></li><li><p><font size="4">冲激函数的导数和积分</font></p><ul><li><p>一阶导数:</p><p>$\int^\infty_{-\infty} \delta^{(1)}(t)\phi (t)dt=\int^\infty_{-\infty}\delta(t)\phi^{(1)}(t)dt=-\phi^{(1)}(0)$  </p><ul><li>n阶导数:</li></ul><p>$\int^\infty_{-\infty} \delta^{(n)}(t)\phi (t)dt=\int^\infty_{-\infty}\delta(t)\phi^{(n)}(t)dt=(-1)^n\phi^{(n)}(0)$  </p><ul><li>阶跃函数的导数(写在这里是为了对比)</li></ul><p>$\int^\infty_{-\infty} \xi^{(1)}(t)\phi (t)dt=\int^\infty_{-\infty}\xi(t)\phi^{(1)}(t)dt=-\phi(0)$ </p><p>到这里,证明了$\delta(t)=\xi (t)^`$.冲激函数是阶跃函数的导数</p></li></ul></li><li><p><font size="4">冲激函数的性质</font></p><ul><li><p>和普通函数的乘积</p><p> $f(t)\delta(t)=f(0)\delta(t)$;</p><p> $\int^\infty_{-\infty} f(t)\delta(t)dt=f(0)$; </p><p> $f(t)\delta^<code>(t)=f(0)\delta^</code>(t)-f^`(0)\delta(t)$;</p><p> $\int^\infty_{-\infty} f(t)\delta^<code>(t)dt=-f^</code>(0)$; </p></li><li><p>移位 </p><p>$\delta (t)$表示t=0处的冲激,t=t1处的冲激可以表示为$\delta(t-t_1)$</p><p>$\int^\infty_{-\infty} \delta^<code>(t-t_1)\phi(t)dt=-\phi^</code>(t_1)$; </p><p>对于普通函数:</p><ul><li><p>$f(t)\delta(t-t_1)=f(t_1)\delta(t-t_1)$</p></li><li><p>$\int _{-\infty}^\infty f(t)\delta(t-t_1)dt=f(t_1)$</p></li><li><p>$f(t)\delta^<code>(t-t_1)=f(t_1)\delta^</code>(t-t_1)-f^`(t_1)\delta(t-t_1)$</p></li><li><p>$\int _{-\infty}^\infty f(t)\delta^<code>(t-t_1)dt=f^</code>(t_1)$</p></li></ul></li><li><p>尺度变换</p><ul><li>$\delta(at)=\frac{1}{|a|}\delta(t)$ </li><li>$\delta^<code>(at)=\frac{1}{|a|}\frac{1}{a}\delta^</code>(t)$</li><li>$\delta^{n}(at)=\frac{1}{|a|}(\frac{1}{a})^{n}\delta^n(t)$</li></ul></li><li><p>奇偶性</p><p>由$\delta^{n}(at)=\frac{1}{|a|}(\frac{1}{a})^{n}\delta^n(t)$,取a=-1.</p><ul><li>n为偶数时$\delta^{n}(-t)=\frac{1}{|-1|}(\frac{1}{-1})^{n}\delta^n(t)$ </li></ul><p>即:$\delta^{n}(t)$是t的偶函数</p><ul><li>n为奇数时$\delta^{n}(-t)=\frac{1}{|-1|}(\frac{1}{-1})^{n}\delta^n(t)$ </li></ul><p>即:$\delta^{n}(t)$是t的奇函数</p></li><li><p>复合函数形式的冲激函数</p><p>$\delta[f(t)]$</p><p>$\delta[f(t)]=\sum_{i=1}^n\frac{1}{|f^`(t_i)|}\delta(t-t_i)$</p><p>含义是:$\delta[f(t)]$是由位于各个$t_i$处,强度为$\frac{1}{|f^`(t_i)|}$的n个冲激函数构成的冲击函数序列.</p><p><strong>其中$t_i是f(t)$=0的根.</strong></p><p><strong>eg.</strong> $f(t)=4t^2-1$,求$\delta[f(t)]$.</p><p>$f^`(t)=8t,f(t)=0的根是t_1=\frac{1}{2},t_2=-\frac{1}{2}$</p><p>$\delta[f(t)]=\frac{1}{4}\delta(t+\frac{1}{2})+\frac{1}{4}\delta(t-\frac{1}{2})$</p></li></ul></li></ul><h2 id="4-系统框图"><a href="#4-系统框图" class="headerlink" title="4.系统框图"></a><font size="5">4.系统框图</font></h2><p><strong>没啥知识点,就是两种例题.</strong></p><p><font size="4"><strong>Eg1.</strong> 求系统的微分方程</font></p><p><img src="0322-picture1.jpg" alt="picture"></p><p>以两个加法器为核心,得到两个方程:(为了方便,我把t省略了)</p><p>$f=x^{(2)}+a_1x^{(1)}+a_0x$,       还有$y=b_2x^{(2)}+b_1x^{(1)}+b_0x$</p><p>变形:</p><p>$a_0y=b_2(a_0x^{(2)})+b_1(a_0x^{(1)})+b_0(a_0x)$</p><p>$a_1y^{(1)}=b_2(a_1x^{(2)})^<code>+b_1(a_1x^{(1)})^</code>+b_0(a_1x)^`)$</p><p>$y^{(2)}=b_2(x^{(2)})^{<code>}+b_1(x^{(1)})^{</code>}+b_0(x)^{``}$</p><p>$y^{<code>}+a_1y^`+a_0y=b_2f^{</code>}+b_1f^`+b_0f$</p><p><strong>特点:</strong> </p><ol><li>给y变形的步骤和f(t)的每一项刚好一一对应</li><li>答案的形式是f(t),y(t)的形式互相交替.</li></ol><p><font size="4"><strong>Eg2.</strong> 求系统的差分方程</font></p><p><img src="0322-picture2.jpg" alt="picture"></p><p>步骤和特点和求微分方程完全一样!!!</p><p>这个例子的答案是:<br>$y(k)+a_1y(k-1)+a_0y(k-2)=b_2f(k)-b_0f(k-2)$</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> -信号与系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成-定点数的加减乘除</title>
      <link href="/2020/03/20/ji-suan-ji-zu-cheng-ding-dian-shu-yun-suan/"/>
      <url>/2020/03/20/ji-suan-ji-zu-cheng-ding-dian-shu-yun-suan/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小代码:&lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;td&gt; </span><br><span class="line">异或: \bigoplus</span><br><span class="line">不等号: \not =</span><br></pre></td></tr></tbody></table></figure><h1 id="一-、定点数加减运算"><a href="#一-、定点数加减运算" class="headerlink" title="一 、定点数加减运算"></a>一 、定点数加减运算</h1><h2 id="1-补码"><a href="#1-补码" class="headerlink" title="1. 补码"></a>1. 补码</h2><h2 id="2-BCD码"><a href="#2-BCD码" class="headerlink" title="2. BCD码"></a>2. BCD码</h2><h2 id="3-移码"><a href="#3-移码" class="headerlink" title="3. 移码"></a>3. 移码</h2><hr><h3 id="1-补码-最常用"><a href="#1-补码-最常用" class="headerlink" title="1. 补码(最常用)"></a>1. 补码(最常用)</h3><ul><li>$[X+Y]_补$=$[X]_补+[Y]_补$</li><li>$[X-Y]_补$=$[X]_补+[-Y]_补$<ul><li>$[-Y]<em>补$=$[[Y]_补]</em>{求补}$</li></ul></li></ul><p><strong>规则:</strong></p><ol><li>所有数用补码表示</li><li>符号位也参加运算</li><li>补充:求补运算简单算法:<ul><li>对于负数:是所有位取反,末位+1.</li><li>对于正数来说,原码就是补码</li></ul></li><li>运算结果也是补码</li></ol><p><strong>问题:</strong> 溢出问题</p><ol><li>异号相加不会溢出</li><li>同号相加才可能溢出</li></ol><p><strong>解决:</strong> 溢出判定</p><p>(我第一次看的时候不知道这有啥用,后来发现,溢出判定实际上是设计数字电路的时候的逻辑)</p><ol><li>双符号位: 00表示正,11表示负: <em>符号位异或,结果是1,则发生了溢出.</em></li><li>进位判决:最高数值位向符号位的进位记为$C_{n-1}$,符号位的进位记为$C_n$.<em>二者异或,结果是1,则发生溢出.</em></li><li>运算符异或进位符:运算结果的符号位结果记为$S_F$,进位标志记为$C_F$,<em>二者异或,结果是1则发生溢出.</em></li><li>根据运算前后的符号位判别.</li></ol><h3 id="2-BCD码-不常用"><a href="#2-BCD码-不常用" class="headerlink" title="2. BCD码(不常用)"></a>2. BCD码(不常用)</h3><p>核心是4位的二进制数是模16运算,BCD码不是.</p><p>以<strong>8421BCD</strong>为例,用<em>4位二进制数</em>,表示<em>1位十进制数</em> .</p><p><strong>矫正:</strong><br>二进制数的结果大于9时,则需要进位,并且-06H作为矫正(因为模16比模10多了6)</p><h3 id="3-移码-和补码差不多"><a href="#3-移码-和补码差不多" class="headerlink" title="3. 移码(和补码差不多)"></a>3. 移码(和补码差不多)</h3><p><strong>规则:</strong></p><ol><li>先对两移码求和差,最后把<strong>结果的符号位取反</strong>作为修正.</li><li>eg: $[57-35]<em>移$=<strong><em>-</em></strong>($[57]_移+[[35]_移]</em>{求补}$)</li></ol><hr><h1 id="二、定点数乘法运算"><a href="#二、定点数乘法运算" class="headerlink" title="二、定点数乘法运算"></a>二、定点数乘法运算</h1><h2 id="1-原码一位"><a href="#1-原码一位" class="headerlink" title="1.原码一位"></a>1.原码一位</h2><h2 id="2-原码二位"><a href="#2-原码二位" class="headerlink" title="2.原码二位"></a>2.原码二位</h2><h2 id="3-补码一位-校正法-amp-Booth法"><a href="#3-补码一位-校正法-amp-Booth法" class="headerlink" title="3.补码一位(校正法&amp;Booth法)"></a>3.补码一位(校正法&amp;Booth法)</h2><h2 id="4-补码二位"><a href="#4-补码二位" class="headerlink" title="4.补码二位"></a>4.补码二位</h2><h3 id="1-原码一位-1"><a href="#1-原码一位-1" class="headerlink" title="1.原码一位"></a>1.原码一位</h3><p><strong>规则:</strong></p><ol><li>乘积的符号位是被乘数和乘数的符号位的异或.</li><li>乘积的绝对值是被惩处的绝对值和乘数的绝对值之积.</li></ol><p><strong>即:[X]原×[Y]原=($X_0\bigoplus Y_0$) ($\mid X \mid \times \mid Y \mid$)</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是代码(我自己学markdown记的,不重要)</span><br><span class="line">($X_0\bigoplus Y_0$) ($\mid X \mid \times \mid Y \mid$)</span><br></pre></td></tr></tbody></table></figure><p>其中$X_0 ,Y_0$是符号位</p><p><strong>eg.$0.1101 \times1.1011$</strong></p><table>   <tbody><tr>      <th>(缓冲区)</th>      <th>D</th>      <th colspan="2">A(最后一个是末位)</th>      <th>原因和操作</th>   </tr>   <tr>      <td>0</td>      <td>0 0 0 0 </td>      <td>1 0 1</td>      <td>1</td>      <td>末位是1,下一行+x</td>   </tr>   <tr>      <td>0</td>      <td>1 1 0 1 </td>      <td>    </td>      <td> </td>      <td>+x</td>   </tr>   <tr>   <td>0</td>      <td>1 1 0 1 </td>      <td>1 0 1</td>      <td>1</td>      <td></td>    </tr>    <tr>   <td>0</td>      <td>0 1 1 0 </td>      <td>1 1 0</td>      <td>1</td>      <td>整体右移一位,末位是1,下一行+x</td>    </tr>       <tr>      <td>0</td>      <td>1 1 0 1 </td>      <td></td>      <td></td>      <td>+x</td>    </tr>    <tr>      <td>1</td>      <td>0 0 1 1 </td>      <td>1 1 0</td>      <td>1</td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>1 0 0 1 </td>      <td>1 1 1</td>      <td>0</td>      <td>右移一位,末位是0,下一行+0</td>    </tr>     <tr>      <td>0</td>      <td>0 0 0 0  </td>      <td></td>      <td></td>      <td>+0</td>    </tr>    <tr>      <td>0</td>      <td>1 0 0 1  </td>      <td>1 1 1</td>      <td>0</td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>0 1 0 0  </td>      <td>1 1 1</td>      <td>1</td>      <td>右移一位,末位是1,下一行+x</td>    </tr>    <tr>      <td>0</td>      <td>1 1 0 1  </td>      <td></td>      <td></td>      <td>+x</td>    </tr>    <tr>      <td>1</td>      <td>0 0 0 1  </td>      <td>1 1 1</td>      <td>1</td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>1 0 0 0   </td>      <td>1 1 1</td>      <td>1</td>      <td>右移一次</td>    </tr></tbody></table><p><strong>结果:</strong> $0.1101 \times1.1011$=1.1000 1111</p><p><strong>特点:</strong> </p><ol><li>被乘数有几位,运算过程就右移几次,每次右移的时候,数值位的首位补0</li><li>符号位不参与运算,运算前先$\bigoplus$,决定结果的符号</li></ol><h3 id="2-原码二位-1"><a href="#2-原码二位-1" class="headerlink" title="2.原码二位"></a>2.原码二位</h3><p><strong>规则:</strong></p><ol><li><p>原理和原码一位一样,只是从电路层面简化了运算步骤</p></li><li><p>记被乘数的最后两位分别为$A_n A_{n-1}$</p></li><li><p>记$C=A_n\bigoplus A_{n-1}$,</p><p>若$C=0$,则下一步操作是-X,</p><p>若$C=1$,则下一步操作的+2X</p></li></ol><p><strong>eg.</strong> X= +0.100 111, Y= -0.100 111 求X$\times$Y</p><p><strong>准备工作:</strong> </p><p>$-X=[X]_补$=1.011 001(第一位是符号位)</p><p>$2X$=01.001 110(第一位是符号位)</p><table> <tbody><tr>  <th>符号位</th>  <th>D</th>  <th colspan="2">A | An-1 An </th>  <th>C=An异或An-1</th>  <th>操作</th> </tr>   <tr>      <td>0 0 0</td>      <td>0 0 0 0 0 0</td>      <td>1 0 0 1</td>      <td>1 1</td>      <td>0</td>      <td>C=0,下一行-x</td>   </tr>   <tr>      <td>1 1 1</td>      <td>0 1 1 0 0 1</td>      <td></td>      <td></td>      <td></td>      <td>-x(+x的补码)</td>   </tr>   <tr>      <td>1 1 1</td>      <td>0 1 1 0 0 1</td>      <td>1 0 0 1</td>      <td>1 1</td>      <td></td>      <td></td>   </tr>   <tr>      <td>1 1 1</td>      <td>1 1 0 1 1 0</td>      <td>0 1 1 0</td>      <td>0 1</td>      <td>1</td>      <td>右移两位,C=1,下一行+2x</td>   </tr>   <tr>      <td>0 0 1</td>      <td>0 0 1 1 1 0</td>      <td></td>      <td></td>      <td></td>      <td>+2x</td>   </tr>   <tr>      <td>0 0 1</td>      <td>0 0 0 1 0 0</td>      <td>0 1 1 0</td>      <td>0 1</td>      <td></td>      <td></td>   </tr>   <tr>      <td>0 0 0</td>      <td>0 1 0 0 0 1</td>      <td>0 0 0 1</td>      <td>1 0</td>      <td>1</td>      <td>右移两位,C=1,下一行+2x</td>   </tr>   <tr>      <td>0 0 1</td>      <td>0 0 1 1 1 0 </td>      <td></td>      <td></td>      <td></td>      <td>+2x</td>   </tr>   <tr>      <td>0 0 1</td>      <td>0 1 1 1 1 1 </td>      <td>0 0 0 1</td>      <td>1 0</td>      <td></td>      <td></td>   </tr>   <tr>      <td>0 0 0</td>      <td>0 1 0 1 1 1 </td>      <td>1 1 0 0</td>      <td>0 1</td>      <td></td>      <td>右移两位,</td>   </tr></tbody></table><p><strong>结果:</strong><br>+0.100 111$\times$-0.100 111=1.0101 1111 0001</p><p>其中第一位是符号位,是由乘数和被乘数异或得到的</p><p><strong>特点:</strong>(和原码一位区别很大)</p><p><strong>移位的时候,缓存区的数字不变,即缓存区原本的数字是什么,就补什么</strong></p><h3 id="3-补码一位"><a href="#3-补码一位" class="headerlink" title="3.补码一位"></a>3.补码一位</h3><h4 id="1-校正法"><a href="#1-校正法" class="headerlink" title="1.校正法"></a>1.校正法</h4><p><strong>规则:</strong><br>和原码类似,但是最后一位要校正.<br>X$\times$Y,<strong>若Y的符号位是1,则运算结果要加上$-[X]_补$</strong></p><p><strong>eg.</strong><br>X=-0.1101,Y=0.1011<br><strong>准备工作:</strong>$[X]_补$=1.0011,<br>$[Y]_补$=0.1011<br>(求补运算的时候符号位不变,第一位是符号位)</p><table> <tbody><tr>  <th>符号</th>  <th>D</th>  <th>A</th>  <th>操作</th> </tr>     <tr>      <td>0 0</td>      <td>0 0 0 0</td>      <td>1 0 1 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td></td>      <td>+X补</td>     </tr>          <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td>1 0 1 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>1 0 0 1</td>      <td>1 1 0 1</td>      <td>右移一位</td>     </tr>     <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td></td>      <td>+X补</td>     </tr>     <tr>      <td>1 0</td>      <td>1 1 0 0</td>      <td>1 1 0 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>0 1 1 0</td>      <td>0 1 1 0</td>      <td>右移一位</td>     </tr>     <tr>      <td>0 0</td>      <td>0 0 0 0</td>      <td></td>      <td>+0</td>     </tr>     <tr>      <td>1 1</td>      <td>0 1 1 0</td>      <td>0 1 1 0</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>1 0 1 1</td>      <td>0 0 1 1</td>      <td>右移一位</td>     </tr>     <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td></td>      <td>+X补</td>     </tr>     <tr>      <td>1 0</td>      <td>1 1 1 0</td>      <td>0 0 1 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>0 1 1 1</td>      <td>0 0 0 1</td>      <td>右移一位</td>     </tr></tbody></table><p><strong>结果:</strong>$[X\times Y]_补$=1.0111 0001</p><p><strong>特点:</strong></p><ol><li>右移补位的时候,首位是啥就补啥.</li><li>+0的时候,0的符号位也是0.</li><li>符号位是一起算出来的,不是两个数的符号位异或直接得到的.</li><li>起始的符号位按00算,不论它本身是正是负.</li><li>最后记得加校正!!!第4点的时候,本身的符号位就是00的话,记得-$[X]_补$</li></ol><p><strong>eg2.</strong></p><p>X=-0.1101,Y=-0.1011</p><p><strong>准备工作:</strong>$[X]_补$=1.0011,<br>$[Y]_补$=0.0101<br>(求补运算的时候符号位不变,第一位是符号位)</p><table> <tbody><tr>  <th>符号</th>  <th>D</th>  <th>A</th>  <th>操作</th> </tr>     <tr>      <td>0 0</td>      <td>0 0 0 0</td>      <td>0 1 0 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td></td>      <td>+X补</td>     </tr>          <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td>0 1 0 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>1 0 0 1</td>      <td>1 0 1 0</td>      <td>右移一位</td>     </tr>     <tr>      <td>0 0</td>      <td>0 0 0 0</td>      <td></td>      <td>+0</td>     </tr>     <tr>      <td>1 1</td>      <td>1 0 0 1</td>      <td>1 0 1 0</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>1 1 0 0</td>      <td>1 1 0 1</td>      <td>右移一位</td>     </tr>     <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td></td>      <td>+X补</td>     </tr>     <tr>      <td>1 0</td>      <td>1 1 1 1</td>      <td>1 1 0 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>0 1 1 1</td>      <td>1 1 1 0</td>      <td>右移一位</td>     </tr>     <tr>      <td>0 0</td>      <td>0 0 0 0</td>      <td></td>      <td>+0</td>     </tr>     <tr>      <td>1 1</td>      <td>0 1 1 1</td>      <td>1 1 1 0</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>1 0 1 1</td>      <td>1 1 1 1</td>      <td>右移一位</td>     </tr>     <tr>      <td>0 0</td>      <td>1 1 0 1</td>      <td></td>      <td>+[-X]补</td>     </tr>     <tr>      <td>0 0</td>      <td>1 0 0 0</td>      <td>1 1 1 1</td>      <td>结果</td>     </tr></tbody></table><p><strong>结果:</strong>$[X\times Y]_补$=0.10001111</p><h4 id="2-Booth法"><a href="#2-Booth法" class="headerlink" title="2.Booth法"></a>2.Booth法</h4><p><strong>规则:</strong> 和原码二位极度相似,但是符号位直接参与运算</p><p>设被乘数$Y$的最后一位是$Y_n$,补一位$A_0$(初值是0),$C=A_0-Y_{n}$</p><table>   <tbody><tr>      <th>Yn</th>      <th>A0</th>      <th>C=A0-Yn</th>      <th>操作</th>   </tr>      <tr>         <td>0</td>         <td>0</td>         <td>0</td>         <td>+0,右移一次</td>      </tr>      <tr>         <td>0</td>         <td>1</td>         <td>1</td>         <td>+[X]补,右移一次</td>      </tr>      <tr>         <td>1</td>         <td>0</td>         <td>-1</td>         <td>+[-X]补,右移一次</td>      </tr>      <tr>         <td>1</td>         <td>1</td>         <td>0</td>         <td>+0,右移一次</td>      </tr></tbody></table><p><strong>eg.</strong> X=0.1010,Y=-0.1101利用Booth法补码一位乘法,求乘积.</p><p><strong>准备工作:</strong>$[X]_补$=0.1010,$[-X]_补$=1.0110,$[Y]_补$=1.0011</p><table>   <tbody><tr>      <th>缓存区</th>      <th>D</th>      <th>A</th>      <th>A0</th>      <th>操作</th>   </tr>      <tr>         <td>0 0</td>         <td>0 0 0 0</td>         <td>1 0 0 1 1</td>         <td>0</td>         <td></td>        </tr>      <tr>         <td>1 1</td>         <td>0 1 1 0</td>         <td></td>         <td></td>         <td>+[-X]补</td>        </tr>      <tr>         <td>1 1</td>         <td>0 1 1 0</td>         <td>1 0 0 1 1</td>         <td>0</td>         <td></td>        </tr>      <tr>         <td>1 1</td>         <td>1 0 1 1</td>         <td>0 1 0 0 1</td>         <td>1</td>         <td>右移一位</td>        </tr>      <tr>         <td>0 0</td>         <td>0 0 0 0</td>         <td></td>         <td></td>         <td>+0</td>        </tr>      <tr>         <td>1 1</td>         <td>1 0 1 1</td>         <td>0 1 0 0 1</td>         <td>1</td>         <td></td>        </tr>      <tr>         <td>1 1</td>         <td>1 1 0 1</td>         <td>1 0 1 0 0</td>         <td>1</td>         <td>右移一位</td>        </tr>      <tr>         <td>0 0</td>         <td>1 0 1 0</td>         <td></td>         <td></td>         <td>+[X]补</td>        </tr>      <tr>         <td>0 0</td>         <td>0 1 1 1</td>         <td>1 0 1 0 0</td>         <td>1</td>         <td></td>        </tr>      <tr>         <td>0 0</td>         <td>0 0 1 1</td>         <td>1 1 0 1 0</td>         <td>0</td>         <td>右移一位</td>        </tr>      <tr>         <td>0 0</td>         <td>0 0 0 0</td>         <td></td>         <td></td>         <td>+0</td>        </tr>      <tr>         <td>0 0</td>         <td>0 0 1 1</td>         <td>1 1 0 1 0</td>         <td>0</td>         <td></td>        </tr>      <tr>         <td>0 0</td>         <td>0 0 0 1</td>         <td>1 1 1 0 1</td>         <td>0</td>         <td>右移一位</td>        </tr>      <tr>         <td>1 1</td>         <td>0 1 1 0</td>         <td></td>         <td></td>         <td>+[-X]补</td>        </tr>      <tr>         <td>1 1</td>         <td>0 1 1 1</td>         <td>1 1 1 0 1</td>         <td>0</td>         <td></td>        </tr>      <tr>         <td>1 1</td>         <td>1 0 1 1 </td>         <td>1 1 1 1 0 </td>         <td>1</td>         <td>右移一位</td>        </tr></tbody></table><p><strong>结果:</strong> $[X\times Y]_补$=1.0111 1110</p><p><strong>特点:</strong> 缓存区不算做结果的符号位,补的$A_0$不算结果,相当于另一个缓存区</p><h3 id="4-补码二位-1"><a href="#4-补码二位-1" class="headerlink" title="4.补码二位"></a>4.补码二位</h3><p><strong>规则:</strong> </p><ol><li>和补码一位的Booth法类似,原理相同,只是在数字电路层面做了优化.<strong><em>记得补前后的缓存区 !</em></strong></li><li>当乘数(包括符号位)位数是偶数n时,右移次数位n/2次,最后一次只移1位(技巧,当补码一位的Booth法考虑)</li></ol><table>   <tbody><tr>      <th>Y(i-2) Y(i-1) Y(i)</th>      <th>Y(i)+Y(i-1)-2Y(i-2)</th>      <th>操作</th>   </tr>      <tr>         <th>0 0 0</th>         <th>0</th>         <th>+0, 右移2位</th>         </tr>      <tr>         <th>0 0 1</th>         <th>1</th>         <th>+[X]补, 右移2位</th>         </tr>      <tr>         <th>0 1 0</th>         <th>1</th>         <th>+[X]补, 右移2位</th>         </tr>      <tr>         <th>0 1 1</th>         <th>2</th>         <th>+2[X]补, 右移2位</th>         </tr>      <tr>         <th>1 0 0</th>         <th>-2</th>         <th>+2[-X]补, 右移2位</th>         </tr>      <tr>         <th>1 0 1</th>         <th>-1</th>         <th>+[-X]补, 右移2位</th>         </tr>      <tr>         <th>1 1 0</th>         <th>-1</th>         <th>+[-X]补, 右移2位</th>         </tr>      <tr>         <th>1 1 1</th>         <th>0</th>         <th>+0, 右移2位</th>         </tr></tbody></table><p><strong>eg.</strong> 已知X=-0.1101,Y=-0.1011,试用补码二位乘法求积.<br><strong>准备工作:</strong> [X]补=1.0011,[Y]补=1.0101,为了不溢出,采用3符号位.<br>[X]补=111.0011 2[X]补=110.0110 [-X]补=000.1101 2[-X]补=001.1010.同时[Y]补=11.0101</p><table>   <tbody><tr>      <th>前缓存区</th>      <th>D</th>      <th>A</th>      <th>后缓存区</th>      <th>操作</th>   </tr>      <tr>         <td>0 0 0</td>         <td>0 0 0 0</td>         <td>1 1 0 1 0 1</td>         <td>0</td>         <td></td>      </tr>      <tr>         <td>1 1 1</td>         <td>0 0 1 1</td>         <td></td>         <td></td>         <td>+[X]补</td>      </tr>      <tr>         <td>1 1 1</td>         <td>0 0 1 1</td>         <td>1 1 0 1 0 1</td>         <td></td>         <td></td>      </tr>      <tr>         <td>1 1 1</td>         <td>1 1 0 0</td>         <td>1 1 1 1 0 1</td>         <td>0</td>         <td>右移2位</td>      </tr>      <tr>         <td>1 1 1</td>         <td>0 0 1 1</td>         <td></td>         <td></td>         <td>+[X]补</td>      </tr>      <tr>         <td>1 1 0</td>         <td>1 1 1 1</td>         <td>1 1 1 1 0 1</td>         <td>0</td>         <td></td>      </tr>      <tr>         <td>1 1 1</td>         <td>1 0 1 1</td>         <td>1 1 1 1 1 1</td>         <td>0</td>         <td>右移2位</td>      </tr>      <tr>         <td>0 0 0</td>         <td>1 1 0 1</td>         <td></td>         <td></td>         <td>+[-X]补</td>      </tr>      <tr>         <td>0 0 0</td>         <td>1 0 0 0</td>         <td>1 1 1 1 1 1 </td>         <td>0</td>         <td></td>      </tr></tbody></table><p><strong>结果:</strong>[X $\cdot$ Y]补=0.1000 1111</p><hr><h1 id="三、定点数除法运算"><a href="#三、定点数除法运算" class="headerlink" title="三、定点数除法运算"></a>三、定点数除法运算</h1><h2 id="1-原码"><a href="#1-原码" class="headerlink" title="1.原码"></a>1.原码</h2><h2 id="2-恢复余数法"><a href="#2-恢复余数法" class="headerlink" title="2.恢复余数法"></a>2.恢复余数法</h2><h2 id="3-加减交替法"><a href="#3-加减交替法" class="headerlink" title="3.加减交替法"></a>3.加减交替法</h2><h3 id="1-原码-1"><a href="#1-原码-1" class="headerlink" title="1.原码"></a>1.原码</h3><p><strong>规则:</strong> </p><ol><li><p>除数$\not ={0}$ ,</p><p>纯小数时,|被除数|&lt;|除数|;</p><p>纯整数时,|被除数|&gt;|除数|.</p></li><li><p>和原码乘法类似,也是符号和绝对值分开处理.<br>(乘法是逐次加乘数,除法是逐次减除数)</p></li></ol><h3 id="2-恢复余数法-1"><a href="#2-恢复余数法-1" class="headerlink" title="2.恢复余数法"></a>2.恢复余数法</h3><p><strong>规则:</strong></p><p>这是为了计算机的运算,根据原码的除法设计的算法,因为计算机只有运算后才知道该商0还是商1,<strong>所以当商了0的时候,应该把减掉的除数加回来.</strong> 其他的和原码运算一样.</p><p><strong>eg.</strong> 被除数X=-0.1000 1011<br>,除数Y=0.1110,用原码恢复余数法,求商和余数.</p><p><strong>准备工作:</strong> 满足|X|&lt;|Y|,|Y|$\not ={0}$.<br>商符号是1$\bigoplus$ 0=1,<br>|X|原=1.1000 1011<br>|Y|原=0.1110</p><table>   <tbody><tr>      <th>缓冲区</th>      <th>被除数(余数)</th>      <th>操作</th>      <th>商</th>   </tr>   <tr>      <td>0 0</td>      <td>1 0 0 0 1 0 1 1</td>      <td></td>      <td></td>   </tr>   <tr>      <td>0 1</td>      <td>0 0 0 1 0 1 1 </td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0 </td>      <td>-Y=+|-Y|补</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>0 0 1 1 0 1 1 </td>      <td>缓冲区结果是00,够减,商1</td>      <td>1</td>   </tr>   <tr>      <td>0 0</td>      <td>0 1 1 0 1 1 </td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0  </td>      <td>-|Y|</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>1 0 0 0 1 1 </td>      <td>缓冲区结果是11,不够减,商0</td>      <td>1 0</td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 1 0 </td>      <td>+|Y|</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>0 1 1 0 1 1 </td>      <td>恢复余数</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 0 1 1 </td>      <td>左移一位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0</td>      <td>-|Y|</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>1 1 1 1 1</td>      <td>商0</td>      <td>1 0 0</td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 1 0</td>      <td>+|Y|</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 0 1 1</td>      <td>恢复余数</td>      <td></td>   </tr>   <tr>      <td>0 1</td>      <td>1 0 1 1</td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0</td>      <td>-|Y|</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 0 1</td>      <td>商1</td>      <td>1 0 0 1</td>   </tr></tbody></table><p><strong>余数小于被除数了,停止计算</strong><br><strong>结果是</strong>商1.1001 余0.1101</p><h3 id="3-加减交替法-1"><a href="#3-加减交替法-1" class="headerlink" title="3.加减交替法"></a>3.加减交替法</h3><p><strong>规则:</strong><br>和恢复余数法一样<br><strong>原理</strong>和恢复余数法完全一样,为了提高效率,商0时,本该恢复余数再-|Y|,改成直接+|Y|.因为左移相当于x2,商0后,如果不恢复余数的话,上次-|Y|的结果就是-2|Y|,所以这次运算直接+|Y|弥补,还是相当于这次-|Y|</p><p><strong>eg.</strong> 若X＝-0.10001011，Y＝0.1110 试利用原码加减交替<br>法求商及余数。</p><p><strong>准备工作:</strong> 符号位=1$\bigoplus$ 0=1,|X|原=1.1000 1011,|Y|原=0.1110.<br>除数Y!=0,|X|&lt;|Y|成立.</p><table>   <tbody><tr>      <th>缓冲区</th>      <th>被除数(余数)</th>      <th>操作</th>      <th>商</th>   </tr>   <tr>      <td>0 0</td>      <td>1 0 0 0 1 0 1 1</td>      <td></td>      <td></td>   </tr>   <tr>      <td>0 1</td>      <td>0 0 0 1 0 1 1 </td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0 </td>      <td>-Y=+|-Y|补</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>0 0 1 1 0 1 1 </td>      <td>缓冲区结果是00,够减,商1</td>      <td>1</td>   </tr>   <tr>      <td>0 0</td>      <td>0 1 1 0 1 1 </td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0  </td>      <td>-|Y|</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>1 0 0 0 1 1 </td>      <td>缓冲区结果是11,不够减,商0</td>      <td>1 0</td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 0 1 1 </td>      <td>左移一位</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 1 0</td>      <td>+|Y|</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>1 1 1 1 1</td>      <td>商0</td>      <td>1 0 0</td>   </tr>   <tr>      <td>1 1</td>      <td>1 1 1 1</td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 1 0</td>      <td>+|Y|</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 0 1 1</td>      <td>商1</td>      <td>1 1 0 1</td>   </tr></tbody></table><p><strong>结果和恢复余数法完全一样</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> -计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法补充-数学公式篇</title>
      <link href="/2020/03/19/markdown-yu-fa-shu-xue-gong-shi-pian/"/>
      <url>/2020/03/19/markdown-yu-fa-shu-xue-gong-shi-pian/</url>
      
        <content type="html"><![CDATA[<h3 id="Markdown语法补充-数学公式篇"><a href="#Markdown语法补充-数学公式篇" class="headerlink" title="Markdown语法补充-数学公式篇"></a>Markdown语法补充-数学公式篇</h3><ol><li><strong>高亮代码块</strong><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><strong>正文中的代码</strong></li></ol><p>正文的代码:<code>int a=0</code></p><ol start="3"><li><strong>插入数学公式</strong></li></ol><p>在文档开头加上下面的javascript代码即可</p><figure class="highlight plain"><figcaption><span>type</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>效果如下:</p><p>When $a \ne 0$, there are two solutions to (ax^2 + bx + c = 0) and they are<br>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$</p><p>mathjax代码如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">When $a \ne 0$, there are two solutions to \(ax^2 + bx + c = 0\) and they are</span><br><span class="line">$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$</span><br></pre></td></tr></tbody></table></figure><p>可以点击<a href="https://www.mathjax.org/" target="_blank" rel="noopener">mathjax官网</a>自己学习</p><h3 id="下面是Mathjax的简明语法"><a href="#下面是Mathjax的简明语法" class="headerlink" title="下面是Mathjax的简明语法:"></a>下面是Mathjax的简明语法:</h3><p>(frac:分数,sum:求和,)</p><ol><li>$\sum_{i=0}^n i^2 = \frac{(n^2 + n)(2n+1)}{6}$</li></ol><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\sum_{i=0}^n i^2 = \frac{(n^2 + n)(2n+1)}{6}$</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>$$\sum_{i=0}^n i2=\frac{(n2+n)(2n+1)}{6}$$</li></ol><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_{i=0}^n i2=\frac{(n2+n)(2n+1)}{6}$$</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>希腊字母</li></ol><p>\alpha: $\alpha$ ,  \Alpha: $\Alpha$</p><p>\beta: $\beta$, \Beta: $Beta$</p><p>\omega: $\omega$ , \Omega: $\Omega$</p><p>\gamma: $\gamma$, \Gamma: $\Gamma$</p><p>\delta: $\delta$, \Delta: $\Delta$</p><p>\theta $\theta$, \Theta: $\Theta$</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\alpha: $\alpha$ ,  \Alpha: $\Alpha$</span><br><span class="line"></span><br><span class="line">\beta: $\beta$, \Beta: $Beta$</span><br><span class="line"></span><br><span class="line">\omega: $\omega$ , \Omega: $\Omega$</span><br><span class="line"></span><br><span class="line">\gamma: $\gamma$, \Gamma: $\Gamma$</span><br><span class="line"></span><br><span class="line">\delta: $\delta$, \Delta: $\Delta$</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li><p>上下角标</p><p>$i^2$  $x_i$ $x_i^2$ $cos\theta^2$ $sin^2\theta$</p></li></ol><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$i^2$  $x_i$ $x_i^2$ $cos\theta^2$ $sin^2\theta$</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><p>上下标组合</p><p>$6^{66}$ $x^{y^2}$</p></li></ol><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$6^{66}$ $x^{y^2}$</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>括号</li></ol><p>$\frac{(x+y)}{[\alpha+\beta]}$</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\frac{(x+y)}{[\alpha+\beta]}$</span><br></pre></td></tr></tbody></table></figure><ol start="7"><li>求积分</li></ol><p>$\int$ $\iint$</p><p>$\int_{i=0}^n$</p><p>$\iint_Df(x,y)d\delta$=$\lim_{x\to\i} \sum_{i=0}^nf(a_i,b_i)\Delta\delta$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$\int$ $\iint$</span><br><span class="line"></span><br><span class="line">$\int_{i=0}^n$</span><br><span class="line"></span><br><span class="line">$\iint_Df(x,y)d\delta$=$\lim_{x\to\\i} \sum_{i=0}^nf(a_i,b_i)\Delta\delta$</span><br></pre></td></tr></tbody></table></figure><ol start="8"><li>连乘</li></ol><p>$\prod$   $\prod_{0}^2$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\prod$   $\prod_{0}^2$</span><br></pre></td></tr></tbody></table></figure><ol start="9"><li>分数</li></ol><p>$\frac1 3$  $\frac{x+y}{a+b}$ $a\over b$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\frac1 3$  $\frac{x+y}{a+b}$ $a\over b$</span><br></pre></td></tr></tbody></table></figure><ol start="10"><li>开根号</li></ol><p>$\sqrt{x+y}$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\sqrt{x+y}$</span><br></pre></td></tr></tbody></table></figure><ol start="11"><li>极限</li></ol><p>$\lim_{x\to\infty}$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\lim_{x\to\infty}$</span><br></pre></td></tr></tbody></table></figure><ol start="12"><li>空格</li></ol><p>$a\ b$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$a\ b$</span><br></pre></td></tr></tbody></table></figure><ol start="13"><li>矩阵</li></ol><p>$\begin{matrix} 1&amp;x&amp;x^2\ 1&amp;y&amp;y^2\ 1&amp;z&amp;z^2 \end{matrix}$<br>$\begin{pmatrix} 1&amp;x&amp;x^2\ 1&amp;y&amp;y^2\ 1&amp;z&amp;z^2 \end{pmatrix}$<br>$\begin{bmatrix} 1&amp;x&amp;x^2\ 1&amp;y&amp;y^2\ 1&amp;z&amp;z^2 \end{bmatrix}$<br>$\begin{Bmatrix} 1&amp;x&amp;x^2\ 1&amp;y&amp;y^2\ 1&amp;z&amp;z^2 \end{Bmatrix}$<br>$\begin{vmatrix} 1&amp;x&amp;x^2\ 1&amp;y&amp;y^2\ 1&amp;z&amp;z^2 \end{vmatrix}$<br>$\left[ \begin{array}{cc|c} 1&amp;2&amp;3\\ 2&amp;3&amp;4 \end{array} \right]$<br>$\left[ \begin{array}{c|cc} 1&amp;2&amp;3\\ 2&amp;3&amp;4 \end{array} \right]$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$\begin{matrix} 1&amp;x&amp;x^2\\ 1&amp;y&amp;y^2\\ 1&amp;z&amp;z^2 \end{matrix}$</span><br><span class="line">$\begin{pmatrix} 1&amp;x&amp;x^2\\ 1&amp;y&amp;y^2\\ 1&amp;z&amp;z^2 \end{pmatrix}$</span><br><span class="line">$\begin{bmatrix} 1&amp;x&amp;x^2\\ 1&amp;y&amp;y^2\\ 1&amp;z&amp;z^2 \end{bmatrix}$</span><br><span class="line">$\begin{Bmatrix} 1&amp;x&amp;x^2\\ 1&amp;y&amp;y^2\\ 1&amp;z&amp;z^2 \end{Bmatrix}$</span><br><span class="line">$\begin{vmatrix} 1&amp;x&amp;x^2\\ 1&amp;y&amp;y^2\\ 1&amp;z&amp;z^2 \end{vmatrix}$</span><br><span class="line">$\left[ \begin{array}{cc|c} 1&amp;2&amp;3\\\ 2&amp;3&amp;4 \end{array} \right]$</span><br><span class="line">$\left[ \begin{array}{c|cc} 1&amp;2&amp;3\\\ 2&amp;3&amp;4 \end{array} \right]$</span><br></pre></td></tr></tbody></table></figure><ol start="14"><li>分段函数<br>$$f(n)=\begin{cases}n/2,&amp;\text{if $n$ is even}\3n+1,&amp;\text{if $n$ is odd}\end{cases}$$</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(n)=\begin{cases}n/2,&amp;\text{if $n$ is even}\\3n+1,&amp;\text{if $n$ is odd}\end{cases}$$</span><br></pre></td></tr></tbody></table></figure><ol start="15"><li>数组和表格<br>$$\begin{array}{cc|c} x_1+1^2&amp;2+x_1^3&amp;3x_1^2+1\\ 4 &amp; 5&amp; 6 \end{array}$$</li></ol><p>$$\begin{array}{c|cc} index&amp;Left&amp;Center&amp;Right\ \hline 1 &amp; 5&amp; 6&amp; 7 \ \hline 2    &amp; 8&amp;    9&amp;    10 \end{array}$$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\begin{array}{cc|c} x_1+1^2&amp;2+x_1^3&amp;3x_1^2+1\\\ 4 &amp; 5&amp; 6 \end{array}$$</span><br><span class="line"></span><br><span class="line">$$\begin{array}{c|cc} index&amp;Left&amp;Center&amp;Right\\ \hline 1 &amp; 5&amp; 6&amp; 7 \\ \hline 2&amp; 8&amp;9&amp;10 \end{array}$$</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> -Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客基础搭建</title>
      <link href="/2020/03/18/hexo-bo-ke-ji-chu-da-jian/"/>
      <url>/2020/03/18/hexo-bo-ke-ji-chu-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo基础搭建步骤"><a href="#hexo基础搭建步骤" class="headerlink" title="hexo基础搭建步骤"></a>hexo基础搭建步骤</h1><p>###首先说说为啥用hexo:</p><p><strong>1.免费,没广告</strong></p><p><strong>2.CSS和html可以自己写,也可以直接用模板,美观,难度适中,适合练手</strong></p><p><strong>3.没有平台审核,方便,自由</strong></p><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h2><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><h2 id="4-Github创建个人仓库"><a href="#4-Github创建个人仓库" class="headerlink" title="4.Github创建个人仓库"></a>4.Github创建个人仓库</h2><h2 id="5-生成SSH添加到Github"><a href="#5-生成SSH添加到Github" class="headerlink" title="5.生成SSH添加到Github"></a>5.生成SSH添加到Github</h2><h2 id="6-将hexo上传到github"><a href="#6-将hexo上传到github" class="headerlink" title="6.将hexo上传到github"></a>6.将hexo上传到github</h2><h2 id="7-发布文章"><a href="#7-发布文章" class="headerlink" title="7.发布文章"></a>7.发布文章</h2><h4 id="以下的安装包都需要科学上网-否则极慢-或者用国内的镜像也可-百度一下-阿里镜像"><a href="#以下的安装包都需要科学上网-否则极慢-或者用国内的镜像也可-百度一下-阿里镜像" class="headerlink" title="(以下的安装包都需要科学上网,否则极慢,或者用国内的镜像也可(百度一下:阿里镜像))"></a>(以下的安装包都需要科学上网,否则极慢,或者用国内的镜像也可(百度一下:<font color="green">阿里镜像</font>))</h4><hr><h2 id="1-安装Git-1"><a href="#1-安装Git-1" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><p><strong>廖雪峰老师的Git教程写的非常好，大家可以看一下。<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">Git教程</a></strong></p><p>  windows：到git官网上下载.exe文件,Download git,安装选项还是全部默认，只不过最后一步添加路径时选择<strong>*Use Git from the Windows Command Prompt</strong>，这样我们就可以直接在命令提示符里打开git了。<br>  安装完后,记得在命令提示符输入 <strong>*git –version</strong>查看是否安装成功</p><hr><h2 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2.安装node.js"></a>2.安装node.js</h2><p>  hexo是基于node.js编写的,需要安装node.js和npm工具<br>  windows：下载稳定版或者最新版都可以,进官网:<strong><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.js</a></strong>，安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入:</p><pre><code>node -vnpm -v，</code></pre><p>如果出现版本号，那么就安装成功了。</p><p>(<a href="https://registry.npm.taobao.org1" target="_blank" rel="noopener">阿里镜像加速node.js下载</a>)</p><p><strong>或者右击任意地方,点击gitBush</strong>,在命令行输入:</p><pre><code>npm config set registry https://registry.npm.taobao.org1</code></pre><hr><h2 id="3-安装Hexo-1"><a href="#3-安装Hexo-1" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>  <strong>先创建一个文件夹MyBlog</strong>,用来存放博客文件,然后cd到这个文件夹下(或者在这个文件夹下右击,点击 git bash即可)<br>  输入下面的命令安装Hexo</p><pre><code>npm install -g hexo-cli</code></pre><p>  安装完输入</p><pre><code>hexo -v</code></pre><p>验证是否安装成功.</p><p>需要安装的东西安完了,</p><p><strong>接下来初始化hexo</strong><br>输入</p><pre><code>hexo init MyBlog(你的文件夹是啥就写啥)</code></pre><p>接着进入这个文件夹(cd或者直接在文件夹里GitBush here都可)<br>输入 </p><pre><code>npm install</code></pre><p>新建完成后，指定文件夹MyBlog目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题** </li><li>_config.yml: 博客的配置文件**</li></ul><p>然后输入 </p><pre><code>hexo generate(简写g)</code></pre><p>再输入 </p><pre><code>hexo server(简写s)</code></pre><p>就可以再本地浏览网页了</p><p>在浏览器输入: <a href="http://localhost4000/" target="_blank" rel="noopener">http://localhost4000/</a></p><p>到这里,初始化完成,建议停一下  认真浏览一下这个初始化的页面,下面的介绍都是官方文档,详细介绍了hexo的操作方法,还有基本参数之类的<br>或者访问<strong><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官网</a></strong>(中文的哟)</p><p>By the way,安装教程就在官网里,甚至国内镜像也有,觉得我写的不详细的话可以直接在官网看.</p><hr><h2 id="4-注册Github账号创建个人仓库"><a href="#4-注册Github账号创建个人仓库" class="headerlink" title="4.注册Github账号创建个人仓库"></a>4.注册Github账号创建个人仓库</h2><p>记得选上<strong>Initialize this repository wiyh a README</strong></p><hr><h2 id="5-生成SSH添加到Github-1"><a href="#5-生成SSH添加到Github-1" class="headerlink" title="5.生成SSH添加到Github"></a>5.生成SSH添加到Github</h2><p>在桌面右击打开 git bush 输入以下命令:</p><pre><code>git config --global user.name "yourname"git config --global user.email "youremail"</code></pre><p><strong>yourname输入Github用户名,youremail输入Github邮箱</strong></p><p>可以输入以下命令检查有没有输对</p><pre><code>git config user.namegit config user.email</code></pre><p>然后输入下面的代码,创建SSH密钥,一路回车(有个步骤是要设置密码,但是没啥用,回车跳过就行)</p><pre><code>ssh-keygen -t rsa -C "youremail"</code></pre><p>然后接着输入</p><pre><code>cat ~/.ssh/id_rsa.pub</code></pre><p><strong>输出的内容就是SSH密钥的公钥</strong>,复制一下</p><p>打开<strong><a href="http://github.com" target="_blank" rel="noopener">github</a></strong>，在头像下面点击<strong>settings</strong>，再点击<strong>SSH and GPG keys</strong>，新建一个SSH，名字随便取一个都可以，把你的<strong>id_rsa.pub里面的信息复制进去(就是刚才复制粘贴的公钥)</strong>。</p><p>最后在git bash输入</p><pre><code>ssh-T git@github.com</code></pre><p>如果没有报错,连接就建立成功了<strong>(你就可以远程控制访问github代码仓库了)</strong></p><hr><h2 id="6-将hexo上传到github-1"><a href="#6-将hexo上传到github-1" class="headerlink" title="6.将hexo上传到github"></a>6.将hexo上传到github</h2><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，<strong>打开博客根目录下的_config.yml文件</strong>，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。<br><strong>修改配置:</strong></p><pre><code>deploy:  type: git  repository: https://github.com/shw2018/shw2018.github.io  branch: master</code></pre><p>  repository填自己的github项目地址</p><p>然后在博客目录下,安装deploy-git,这样才能同步到github的远程仓库上<br>输入: </p><pre><code>npm install hexo-deployer-git --save</code></pre><p>最后输入: </p><pre><code>hexo clean //(清理public文件) hexo generate //(生成静态页面)hexo deploy //(上传到github)</code></pre><p>到这里,hexo基本搭建就完成了</p><hr><h2 id="7-发表博客"><a href="#7-发表博客" class="headerlink" title="7.发表博客"></a>7.发表博客</h2><p>在博客根目录下的source文件夹创建.md后缀的文件,windows建议下载一个<a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkDownPad</a>,用MarkdownPad写博客内容即可.</p><p><a href="https://ricado-xv.github.io/2020/03/09/markdown-yu-fa/">Markdown简明语法</a></p><h1 id="超级感谢参考博客-洪卫の博客"><a href="#超级感谢参考博客-洪卫の博客" class="headerlink" title="超级感谢参考博客:洪卫の博客"></a>超级感谢参考博客:<a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-4" target="_blank" rel="noopener">洪卫の博客</a></h1><h1 id="廖雪峰老师的Git教程写的非常好，大家可以看一下。Git教程"><a href="#廖雪峰老师的Git教程写的非常好，大家可以看一下。Git教程" class="headerlink" title="廖雪峰老师的Git教程写的非常好，大家可以看一下。Git教程"></a>廖雪峰老师的Git教程写的非常好，大家可以看一下。<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">Git教程</a></h1><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> -hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举类型的秘密</title>
      <link href="/2020/03/17/mei-ju-lei-xing-de-mi-mi/"/>
      <url>/2020/03/17/mei-ju-lei-xing-de-mi-mi/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举类型的好处"><a href="#枚举类型的好处" class="headerlink" title="枚举类型的好处"></a>枚举类型的好处</h1><hr><h3 id="1-约束性好-减少错误"><a href="#1-约束性好-减少错误" class="headerlink" title="1.约束性好,减少错误:"></a>1.约束性好,减少错误:</h3><h3 id="以B站上传视频为例-视频一般有三个状态-草稿-审核-发布-可以定义位静态常量"><a href="#以B站上传视频为例-视频一般有三个状态-草稿-审核-发布-可以定义位静态常量" class="headerlink" title="以B站上传视频为例,视频一般有三个状态:草稿,审核,发布.可以定义位静态常量:"></a>以B站上传视频为例,视频一般有三个状态:草稿,审核,发布.可以定义位静态常量:</h3><h5 id="不用枚举类型"><a href="#不用枚举类型" class="headerlink" title="不用枚举类型:"></a>不用枚举类型:</h5><pre><code>  public class VideoStatus{  public static final int Draft=1;//草稿  public static final int Review=2;//审核  public static final int Published=3;//发表} void judgeVideoStatus(int status){//判断状态的函数,由于没  有类型上的约束,任意一个int值都可以,不会报错  ...}</code></pre><h5 id="用枚举类型"><a href="#用枚举类型" class="headerlink" title="用枚举类型:"></a>用枚举类型:</h5><pre><code>public enum VideoStatus{  Draft,Review,Published}void judgeVideoStatus(VideoStatus status){//这里传入参数的约束很明确,不容易出错  ...}</code></pre><hr><h3 id="2-枚举类型通常的方法"><a href="#2-枚举类型通常的方法" class="headerlink" title="2.枚举类型通常的方法:"></a>2.枚举类型通常的方法:</h3><h5 id="以后台管理系统为例-角色一般是固定的-有系统管理员-订单管理员-普通用户"><a href="#以后台管理系统为例-角色一般是固定的-有系统管理员-订单管理员-普通用户" class="headerlink" title="以后台管理系统为例,角色一般是固定的,有系统管理员,订单管理员,普通用户."></a>以后台管理系统为例,角色一般是固定的,有系统管理员,订单管理员,普通用户.</h5><pre><code>public enum UserRole{  ROLE_ROOT_ADMIN,//系统管理员  ROLE_ORDER_ADMIN,//订单管理员  ROLE_NORMAL //普通用户}UserRole role1=UserRole.ROLE_ROOT_ADMIN;UserRole role2=UserRole.ROLE_ORDER_ADMIN;UserRole role3=UserRole.ROLE_NORMAL;for(UserRole role : UserRole.values() ){  System.out.printIn(role);//打印出各个role的值}//ordinal()方法: 返回枚举常量的序数,注意从0开始System.out.printIn(role1.ordinal() );//打印出数组编号,这个是0System.out.printIn(role2.ordinal() );//打印出数组编号,这个是1System.out.printIn(role3.ordinal() );//打印出数组编号,这个是2   //compareTo()方法: 枚举常量顺序的比较System.out.printIn(role1.compareTo(role2) );//打印-1System.out.printIn(role2.compareTo(role3) );//打印-1System.out.printIn(role1.compareTo(role3) );//打印-2//name()方法: 获取枚举常量的名称System.out.printIn(role1.name() );//打印ROLE_ROOT_ADMINSystem.out.printIn(role2.name() );//打印ROLE_ORDER_ADMINSystem.out.printIn(role3.name() );//打印ROLE_NORMAL//valueOf()方法: 返回指定名称的枚举常量System.out.printIn(UserRole.valueOf("ROLE_ROOT_ADMIN") );//打印role1System.out.printIn(UserRole.valueOf("ROLE_ORDER_ADMIN") );//打印role2System.out.printIn(UserRole.valueOf("ROLE_NORMAL") );//打印role3</code></pre><h5 id="除此之外-枚举还可用于switch语句里"><a href="#除此之外-枚举还可用于switch语句里" class="headerlink" title="除此之外,枚举还可用于switch语句里"></a>除此之外,枚举还可用于switch语句里</h5><pre><code>switch(userRole){  case ROLE_NORMAL:     ...     break;  case ROLE_ORDER_ADMIN:     ...     break;  case ROLE_ROOT_ADMIN:     ...     break;}</code></pre><hr><h3 id="3-枚举类型的拓展性"><a href="#3-枚举类型的拓展性" class="headerlink" title="3.枚举类型的拓展性:"></a>3.枚举类型的拓展性:</h3><h5 id="例如在枚举里加入角色名-编码的对应关系-并且自定义一些属性-构造函数-甚至各种方法-和class一样"><a href="#例如在枚举里加入角色名-编码的对应关系-并且自定义一些属性-构造函数-甚至各种方法-和class一样" class="headerlink" title="例如在枚举里加入角色名-编码的对应关系,并且自定义一些属性,构造函数,甚至各种方法.和class一样."></a>例如在枚举里加入角色名-编码的对应关系,并且自定义一些属性,构造函数,甚至各种方法.和class一样.</h5><pre><code>  public enum UserRole{  ROLE_ROOT_ADMIN( "系统管理员",000000),  ROLE_ORDER_ADMIN( "订单管理员",100000),  ROLE_NORMAL("普通用户",200000),  ;  //自定义属性  private final String roleName;//角色名称  private final Integer roleCode;//角色编码  //自定义构造函数  UserRole( String roleName,Integer roleCode){     this.roleName=roleName;     this.roleCode=roleCode;  }  //自定义方法  public String getRoleName(){     return this.roleName;  }  public Integer getRoleCode(){     return this.roleCode;  }  public static Integer getRoleCodebyRoleName( String roleName){     for(UserRole enums: UserRole.values()){        if(enums.getRoleName.equals(roleName)){           return enums.getRoleCode;        }     }     return null;  }}</code></pre><hr><h3 id="4-枚举-接口"><a href="#4-枚举-接口" class="headerlink" title="4.枚举+接口:"></a>4.枚举+接口:</h3><h5 id="可以消灭if-else-增强代码的可读性"><a href="#可以消灭if-else-增强代码的可读性" class="headerlink" title="可以消灭if/else,增强代码的可读性"></a>可以消灭if/else,增强代码的可读性</h5><pre><code>//定义一个公用接口RoleOperation,表示不同角色的操作public interface RoleOperation{  String op();//表示某个角色可以做哪些op操作}//下面定义一个枚举类RoleEnum,用它实现RoleOperation接口public enum RoleEnum implements RoleOperation{  //系统管理员有A权限  ROLE_ROOT_ADMIN{     @override     public String op(){        return "ROLE_ROOT_ADMIN"+"has A permission";     }  },  //订单管理员有B权限  ROLE_ORDER_ADMIN{     @override     public String op(){        return "ROLE_ORDER_ADMIN"+"has B permission";     }  },  //普通用户有C权限  ROLE_NORMAL{     @override     public String op(){        return "ROLE_NORMAL"+"has C permission";     }  };}public class JudgeRole{  public String judge(String roleName){     return RoleEnum.valueOf(roleName).op();  }}</code></pre><hr><h3 id="5-枚举与设计模式"><a href="#5-枚举与设计模式" class="headerlink" title="5. 枚举与设计模式"></a>5. 枚举与设计模式</h3><h5 id="①-单例模式"><a href="#①-单例模式" class="headerlink" title="① 单例模式"></a>① 单例模式</h5><pre><code>public class Singleton{  //构造函数私有化,避免外部创建实例  private Singleton(){  }  //定义一个内部枚举  public enum SingletonEnum{     SEED;//唯一一个枚举对象     private Singleton singleton;     SingletonEnum(){        singleton=new Singleton();//这里才是真正的对象,实例化了     }     public Singleton getInstnce(){        return singleton;     }  }  //外漏对象的获取方法,这是外面获取实例的唯一入口  public static Singleton getInstnce(){     return SingletonEnum.SEED.getInstnce();//通过唯一的枚举对象完成  }</code></pre><p>   }</p><h5 id="②策略模式"><a href="#②策略模式" class="headerlink" title="②策略模式"></a>②策略模式</h5><h5 id="这里举例写一个加减乘除计算器"><a href="#这里举例写一个加减乘除计算器" class="headerlink" title="这里举例写一个加减乘除计算器"></a>这里举例写一个加减乘除计算器</h5><pre><code>public class Test{  public enum Calculator{     ADDITION{//加法        public Double execute(Double x,Double y){           return x+y;        }     },     SUBTRACTION{//减法        public Double execute(Double x,Double y){           return x-y;        }     },     MULTIPLICATION{//乘法        public Double execute(Double x,Double y){           return x*y;        }     },     DIVISION{//除法        public Double execute(Double x,Double y){           return x/y;        }     };     public abstract Double execute(Double x,Double y);//抽象方法,可以避免产生这个抽象类的实例化对象  }  public static void main(String[] args){     System.out.printIn(Calculator.ADDITION.execute(4.0,2.0));//打印6.0  }</code></pre><p>   }</p><hr><h3 id="6-专用于枚举的集合类"><a href="#6-专用于枚举的集合类" class="headerlink" title="6.专用于枚举的集合类"></a>6.专用于枚举的集合类</h3><h5 id="对应于HashMap和HashSet-枚举有专门的集合类-EnumSet和EnumMap"><a href="#对应于HashMap和HashSet-枚举有专门的集合类-EnumSet和EnumMap" class="headerlink" title="对应于HashMap和HashSet,枚举有专门的集合类:EnumSet和EnumMap"></a>对应于HashMap和HashSet,枚举有专门的集合类:EnumSet和EnumMap</h5><h5 id="以开头的枚举类型为例"><a href="#以开头的枚举类型为例" class="headerlink" title="以开头的枚举类型为例:"></a>以开头的枚举类型为例:</h5><pre><code>public enum UserRole{   ROLE_NORMAL,ROLE_ORDER_ADMIN,ROLE_ROOT_ADMIN}</code></pre><h5 id="①EnumSet"><a href="#①EnumSet" class="headerlink" title="①EnumSet"></a>①EnumSet</h5><h5 id="比如系统里来了一批人-查看他是不是枚举类型里的某个角色"><a href="#比如系统里来了一批人-查看他是不是枚举类型里的某个角色" class="headerlink" title="比如系统里来了一批人,查看他是不是枚举类型里的某个角色"></a>比如系统里来了一批人,查看他是不是枚举类型里的某个角色</h5><pre><code>//定义一个管理员角色的专属集合EnumSet&lt;UserRole&gt; userRoleForAdmin  =EnumSet.of(     UserRole.ROLE_ORDER_ADMIN,     UserRole.ROLE_ROOT_ADMIN  );//判断某个进来的用户是不是管理员Boolean isAdmin(User user){  if( userRoles.contains(user.getUserRole()))//java.lang.String里的函数,返回主体是否包含了括号里的参数  /*String s='It's great to see you here.'   Boolean c=s.contains(".")*/     return true;  return false; }</code></pre><h5 id="②EnumMap"><a href="#②EnumMap" class="headerlink" title="②EnumMap"></a>②EnumMap</h5><h5 id="EnumMap用来存放枚举类型为key的Map类型"><a href="#EnumMap用来存放枚举类型为key的Map类型" class="headerlink" title="EnumMap用来存放枚举类型为key的Map类型"></a>EnumMap用来存放枚举类型为key的Map类型</h5><h5 id="比如-系统里来了一批人-我们统计不同的角色到底有多少人"><a href="#比如-系统里来了一批人-我们统计不同的角色到底有多少人" class="headerlink" title="比如,系统里来了一批人,我们统计不同的角色到底有多少人:"></a>比如,系统里来了一批人,我们统计不同的角色到底有多少人:</h5><pre><code>Map&lt;UserRole,Integer&gt; userStatisticMap=new EnumMap&lt;&gt;(UserRole.class);for(User user : userList){  Integer num=userStatisticMap.get(user.getUserRole() );  if(null!=num){     userStatisticMap.put(user.getUserRole(),num+1);  }else{     userStatisticMap.put(user.getUserRole(),1);  }}</code></pre><h1 id="感谢微信公众号CodeSheep"><a href="#感谢微信公众号CodeSheep" class="headerlink" title="感谢微信公众号CodeSheep"></a>感谢微信公众号CodeSheep</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown简明语法</title>
      <link href="/2020/03/09/markdown-yu-fa/"/>
      <url>/2020/03/09/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-blog搭建教程-clik-here"><a href="#hexo-blog搭建教程-clik-here" class="headerlink" title="hexo blog搭建教程(clik here)"></a>hexo blog搭建教程<a href="https://www.itrhx.com/2018/08/15/A02-hexo-blog/" target="_blank" rel="noopener">(clik here)</a></h1><p><strong>一个人来到田纳西</strong></p><p><em>毫无疑问</em></p><p>*我做的馅饼 </p><p>是全天下*</p><p><em>最好吃的</em></p><hr><blockquote><p>引用</p><blockquote><p>引用中的引用</p></blockquote></blockquote><hr><h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><p>#一级标题<br>##二级标题<br>###三级标题<br>####四级标题<br>#####五级标题<br>######六级标题</p><ul><li>无序列表</li></ul><ul><li>无序列表</li></ul><ul><li>无序列表</li></ul><ol><li>1.有序列表</li><li>2.有序列表</li><li>3.有序列表</li></ol><ul><li>嵌套列表<ul><li>嵌套列表<ul><li>嵌套列表</li></ul><ul><li>嵌套列表</li></ul></li></ul><ul><li>嵌套列表</li></ul></li></ul><hr><h2 id="参考来源-不如Blog"><a href="#参考来源-不如Blog" class="headerlink" title="参考来源: 不如Blog"></a>参考来源: <a href="http://bruce-sha.github.io" target="_blank" rel="noopener" title="不如的博客">不如Blog</a></h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png" alt="Github Mark" title="GitHub Mark"></h2><p><strong><em>Reference方式索引</em></strong><br><a href="ibruce.info/2013/11/26/markdown/">不如(markdown语法)</a></p><p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png" alt="Github Octocat"></p><hr><p><strong>自动链接</strong><br>(还是不如的blog)<br><a href="http://ibruce.info" target="_blank" rel="noopener">http://ibruce.info</a></p><hr><p><strong>代码:行内代码</strong></p><p>  val s = “hello Markdown”<br>  println( s )</p><p><strong>代码:段落代码</strong></p><pre><code>val s= "hello Markdown"println( s )&lt;!--注释--&gt;</code></pre><hr><p><strong>转义字符</strong></p><p>\</p><p>`</p><p>*</p><p>_</p><p>{拉拉拉}</p><p>[啦啦啦]</p><p>(啦啦啦)</p><p>#</p><p>+</p><p>-</p><p>.</p><p>!</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code>文本可以直接用html标签但是前后要加空行</code></pre><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>|| <em>year</em> || <em>Temperature (low)</em> || <em>Temperature(high)</em> ||</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> -Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/08/hello-world/"/>
      <url>/2020/03/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MarkDown语法-数学公式篇</title>
      <link href="/2020/03/19/markdown-yu-fa-shu-xue-gong-shi-pian/"/>
      <url>/2020/03/19/markdown-yu-fa-shu-xue-gong-shi-pian/</url>
      
        <content type="html"><![CDATA[<h3 id="Markdown语法补充-数学公式篇"><a href="#Markdown语法补充-数学公式篇" class="headerlink" title="Markdown语法补充-数学公式篇"></a>Markdown语法补充-数学公式篇</h3><ol><li><strong>高亮代码块</strong><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><strong>正文中的代码</strong></li></ol><p>正文的代码:<code>int a=0</code></p><ol start="3"><li><strong>插入数学公式</strong></li></ol><p>在文档开头加上下面的javascript代码即可</p><figure class="highlight plain"><figcaption><span>type</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>效果如下:</p><p>When $a \ne 0$, there are two solutions to (ax^2 + bx + c = 0) and they are<br>$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$</p><p>mathjax代码如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">When $a \ne 0$, there are two solutions to \(ax^2 + bx + c = 0\) and they are</span><br><span class="line">$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$</span><br></pre></td></tr></tbody></table></figure><p>可以点击<a href="https://www.mathjax.org/" target="_blank" rel="noopener">mathjax官网</a>自己学习</p><h3 id="下面是Mathjax的简明语法"><a href="#下面是Mathjax的简明语法" class="headerlink" title="下面是Mathjax的简明语法:"></a>下面是Mathjax的简明语法:</h3><p>(frac:分数,sum:求和,)</p><ol><li>$\sum_{i=0}^n i^2 = \frac{(n^2 + n)(2n+1)}{6}$</li></ol><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\sum_{i=0}^n i^2 = \frac{(n^2 + n)(2n+1)}{6}$</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>$$\sum_{i=0}^n i2=\frac{(n2+n)(2n+1)}{6}$$</li></ol><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_{i=0}^n i2=\frac{(n2+n)(2n+1)}{6}$$</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>希腊字母</li></ol><p>\alpha: $\alpha$ ,  \Alpha: $\Alpha$</p><p>\beta: $\beta$, \Beta: $Beta$</p><p>\omega: $\omega$ , \Omega: $\Omega$</p><p>\gamma: $\gamma$, \Gamma: $\Gamma$</p><p>\delta: $\delta$, \Delta: $\Delta$</p><p>\theta $\theta$, \Theta: $\Theta$</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\alpha: $\alpha$ ,  \Alpha: $\Alpha$</span><br><span class="line"></span><br><span class="line">\beta: $\beta$, \Beta: $Beta$</span><br><span class="line"></span><br><span class="line">\omega: $\omega$ , \Omega: $\Omega$</span><br><span class="line"></span><br><span class="line">\gamma: $\gamma$, \Gamma: $\Gamma$</span><br><span class="line"></span><br><span class="line">\delta: $\delta$, \Delta: $\Delta$</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li><p>上下角标</p><p>$i^2$  $x_i$ $x_i^2$ $cos\theta^2$ $sin^2\theta$</p></li></ol><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$i^2$  $x_i$ $x_i^2$ $cos\theta^2$ $sin^2\theta$</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><p>上下标组合</p><p>$6^{66}$ $x^{y^2}$</p></li></ol><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$6^{66}$ $x^{y^2}$</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>括号</li></ol><p>$\frac{(x+y)}{[\alpha+\beta]}$</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\frac{(x+y)}{[\alpha+\beta]}$</span><br></pre></td></tr></tbody></table></figure><ol start="7"><li>求积分</li></ol><p>$\int$ $\iint$</p><p>$\int_{i=0}^n$</p><p>$\iint_Df(x,y)d\delta$=$\lim_{x\to\i} \sum_{i=0}^nf(a_i,b_i)\Delta\delta$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$\int$ $\iint$</span><br><span class="line"></span><br><span class="line">$\int_{i=0}^n$</span><br><span class="line"></span><br><span class="line">$\iint_Df(x,y)d\delta$=$\lim_{x\to\\i} \sum_{i=0}^nf(a_i,b_i)\Delta\delta$</span><br></pre></td></tr></tbody></table></figure><ol start="8"><li>连乘</li></ol><p>$\prod$   $\prod_{0}^2$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\prod$   $\prod_{0}^2$</span><br></pre></td></tr></tbody></table></figure><ol start="9"><li>分数</li></ol><p>$\frac1 3$  $\frac{x+y}{a+b}$ $a\over b$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\frac1 3$  $\frac{x+y}{a+b}$ $a\over b$</span><br></pre></td></tr></tbody></table></figure><ol start="10"><li>开根号</li></ol><p>$\sqrt{x+y}$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\sqrt{x+y}$</span><br></pre></td></tr></tbody></table></figure><ol start="11"><li>极限</li></ol><p>$\lim_{x\to\infty}$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\lim_{x\to\infty}$</span><br></pre></td></tr></tbody></table></figure><ol start="12"><li>空格</li></ol><p>$a\ b$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$a\ b$</span><br></pre></td></tr></tbody></table></figure><ol start="13"><li>矩阵</li></ol><p>$\begin{matrix} 1&amp;x&amp;x^2\ 1&amp;y&amp;y^2\ 1&amp;z&amp;z^2 \end{matrix}$<br>$\begin{pmatrix} 1&amp;x&amp;x^2\ 1&amp;y&amp;y^2\ 1&amp;z&amp;z^2 \end{pmatrix}$<br>$\begin{bmatrix} 1&amp;x&amp;x^2\ 1&amp;y&amp;y^2\ 1&amp;z&amp;z^2 \end{bmatrix}$<br>$\begin{Bmatrix} 1&amp;x&amp;x^2\ 1&amp;y&amp;y^2\ 1&amp;z&amp;z^2 \end{Bmatrix}$<br>$\begin{vmatrix} 1&amp;x&amp;x^2\ 1&amp;y&amp;y^2\ 1&amp;z&amp;z^2 \end{vmatrix}$<br>$\left[ \begin{array}{cc|c} 1&amp;2&amp;3\\ 2&amp;3&amp;4 \end{array} \right]$<br>$\left[ \begin{array}{c|cc} 1&amp;2&amp;3\\ 2&amp;3&amp;4 \end{array} \right]$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$\begin{matrix} 1&amp;x&amp;x^2\\ 1&amp;y&amp;y^2\\ 1&amp;z&amp;z^2 \end{matrix}$</span><br><span class="line">$\begin{pmatrix} 1&amp;x&amp;x^2\\ 1&amp;y&amp;y^2\\ 1&amp;z&amp;z^2 \end{pmatrix}$</span><br><span class="line">$\begin{bmatrix} 1&amp;x&amp;x^2\\ 1&amp;y&amp;y^2\\ 1&amp;z&amp;z^2 \end{bmatrix}$</span><br><span class="line">$\begin{Bmatrix} 1&amp;x&amp;x^2\\ 1&amp;y&amp;y^2\\ 1&amp;z&amp;z^2 \end{Bmatrix}$</span><br><span class="line">$\begin{vmatrix} 1&amp;x&amp;x^2\\ 1&amp;y&amp;y^2\\ 1&amp;z&amp;z^2 \end{vmatrix}$</span><br><span class="line">$\left[ \begin{array}{cc|c} 1&amp;2&amp;3\\\ 2&amp;3&amp;4 \end{array} \right]$</span><br><span class="line">$\left[ \begin{array}{c|cc} 1&amp;2&amp;3\\\ 2&amp;3&amp;4 \end{array} \right]$</span><br></pre></td></tr></tbody></table></figure><ol start="14"><li>分段函数<br>$$f(n)=\begin{cases}n/2,&amp;\text{if $n$ is even}\3n+1,&amp;\text{if $n$ is odd}\end{cases}$$</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(n)=\begin{cases}n/2,&amp;\text{if $n$ is even}\\3n+1,&amp;\text{if $n$ is odd}\end{cases}$$</span><br></pre></td></tr></tbody></table></figure><ol start="15"><li>数组和表格<br>$$\begin{array}{cc|c} x_1+1^2&amp;2+x_1^3&amp;3x_1^2+1\\ 4 &amp; 5&amp; 6 \end{array}$$</li></ol><p>$$\begin{array}{c|cc} index&amp;Left&amp;Center&amp;Right\ \hline 1 &amp; 5&amp; 6&amp; 7 \ \hline 2    &amp; 8&amp;    9&amp;    10 \end{array}$$</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\begin{array}{cc|c} x_1+1^2&amp;2+x_1^3&amp;3x_1^2+1\\\ 4 &amp; 5&amp; 6 \end{array}$$</span><br><span class="line"></span><br><span class="line">$$\begin{array}{c|cc} index&amp;Left&amp;Center&amp;Right\\ \hline 1 &amp; 5&amp; 6&amp; 7 \\ \hline 2&amp; 8&amp;9&amp;10 \end{array}$$</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客基础搭建</title>
      <link href="/2020/03/18/hexo-bo-ke-ji-chu-da-jian/"/>
      <url>/2020/03/18/hexo-bo-ke-ji-chu-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo基础搭建步骤"><a href="#hexo基础搭建步骤" class="headerlink" title="hexo基础搭建步骤"></a>hexo基础搭建步骤</h1><p>###首先说说为啥用hexo:</p><p><strong>1.免费,没广告</strong></p><p><strong>2.CSS和html可以自己写,也可以直接用模板,美观,难度适中,适合练手</strong></p><p><strong>3.没有平台审核,方便,自由</strong></p><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h2><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><h2 id="4-Github创建个人仓库"><a href="#4-Github创建个人仓库" class="headerlink" title="4.Github创建个人仓库"></a>4.Github创建个人仓库</h2><h2 id="5-生成SSH添加到Github"><a href="#5-生成SSH添加到Github" class="headerlink" title="5.生成SSH添加到Github"></a>5.生成SSH添加到Github</h2><h2 id="6-将hexo上传到github"><a href="#6-将hexo上传到github" class="headerlink" title="6.将hexo上传到github"></a>6.将hexo上传到github</h2><h2 id="7-发布文章"><a href="#7-发布文章" class="headerlink" title="7.发布文章"></a>7.发布文章</h2><h4 id="以下的安装包都需要科学上网-否则极慢-或者用国内的镜像也可-百度一下-阿里镜像"><a href="#以下的安装包都需要科学上网-否则极慢-或者用国内的镜像也可-百度一下-阿里镜像" class="headerlink" title="(以下的安装包都需要科学上网,否则极慢,或者用国内的镜像也可(百度一下:阿里镜像))"></a>(以下的安装包都需要科学上网,否则极慢,或者用国内的镜像也可(百度一下:<font color="green">阿里镜像</font>))</h4><hr><h2 id="1-安装Git-1"><a href="#1-安装Git-1" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><p><strong>廖雪峰老师的Git教程写的非常好，大家可以看一下。<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">Git教程</a></strong></p><p>  windows：到git官网上下载.exe文件,Download git,安装选项还是全部默认，只不过最后一步添加路径时选择<strong>*Use Git from the Windows Command Prompt</strong>，这样我们就可以直接在命令提示符里打开git了。<br>  安装完后,记得在命令提示符输入 <strong>*git –version</strong>查看是否安装成功</p><hr><h2 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2.安装node.js"></a>2.安装node.js</h2><p>  hexo是基于node.js编写的,需要安装node.js和npm工具<br>  windows：下载稳定版或者最新版都可以,进官网:<strong><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.js</a></strong>，安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入:</p><pre><code>node -vnpm -v，</code></pre><p>如果出现版本号，那么就安装成功了。</p><p>(<a href="https://registry.npm.taobao.org1" target="_blank" rel="noopener">阿里镜像加速node.js下载</a>)</p><p><strong>或者右击任意地方,点击gitBush</strong>,在命令行输入:</p><pre><code>npm config set registry https://registry.npm.taobao.org1</code></pre><hr><h2 id="3-安装Hexo-1"><a href="#3-安装Hexo-1" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>  <strong>先创建一个文件夹MyBlog</strong>,用来存放博客文件,然后cd到这个文件夹下(或者在这个文件夹下右击,点击 git bash即可)<br>  输入下面的命令安装Hexo</p><pre><code>npm install -g hexo-cli</code></pre><p>  安装完输入</p><pre><code>hexo -v</code></pre><p>验证是否安装成功.</p><p>需要安装的东西安完了,</p><p><strong>接下来初始化hexo</strong><br>输入</p><pre><code>hexo init MyBlog(你的文件夹是啥就写啥)</code></pre><p>接着进入这个文件夹(cd或者直接在文件夹里GitBush here都可)<br>输入 </p><pre><code>npm install</code></pre><p>新建完成后，指定文件夹MyBlog目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题** </li><li>_config.yml: 博客的配置文件**</li></ul><p>然后输入 </p><pre><code>hexo generate(简写g)</code></pre><p>再输入 </p><pre><code>hexo server(简写s)</code></pre><p>就可以再本地浏览网页了</p><p>在浏览器输入: <a href="http://localhost4000/" target="_blank" rel="noopener">http://localhost4000/</a></p><p>到这里,初始化完成,建议停一下  认真浏览一下这个初始化的页面,下面的介绍都是官方文档,详细介绍了hexo的操作方法,还有基本参数之类的<br>或者访问<strong><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官网</a></strong>(中文的哟)</p><p>By the way,安装教程就在官网里,甚至国内镜像也有,觉得我写的不详细的话可以直接在官网看.</p><hr><h2 id="4-注册Github账号创建个人仓库"><a href="#4-注册Github账号创建个人仓库" class="headerlink" title="4.注册Github账号创建个人仓库"></a>4.注册Github账号创建个人仓库</h2><p>记得选上<strong>Initialize this repository wiyh a README</strong></p><hr><h2 id="5-生成SSH添加到Github-1"><a href="#5-生成SSH添加到Github-1" class="headerlink" title="5.生成SSH添加到Github"></a>5.生成SSH添加到Github</h2><p>在桌面右击打开 git bush 输入以下命令:</p><pre><code>git config --global user.name "yourname"git config --global user.email "youremail"</code></pre><p><strong>yourname输入Github用户名,youremail输入Github邮箱</strong></p><p>可以输入以下命令检查有没有输对</p><pre><code>git config user.namegit config user.email</code></pre><p>然后输入下面的代码,创建SSH密钥,一路回车(有个步骤是要设置密码,但是没啥用,回车跳过就行)</p><pre><code>ssh-keygen -t rsa -C "youremail"</code></pre><p>然后接着输入</p><pre><code>cat ~/.ssh/id_rsa.pub</code></pre><p><strong>输出的内容就是SSH密钥的公钥</strong>,复制一下</p><p>打开<strong><a href="http://github.com" target="_blank" rel="noopener">github</a></strong>，在头像下面点击<strong>settings</strong>，再点击<strong>SSH and GPG keys</strong>，新建一个SSH，名字随便取一个都可以，把你的<strong>id_rsa.pub里面的信息复制进去(就是刚才复制粘贴的公钥)</strong>。</p><p>最后在git bash输入</p><pre><code>ssh-T git@github.com</code></pre><p>如果没有报错,连接就建立成功了<strong>(你就可以远程控制访问github代码仓库了)</strong></p><hr><h2 id="6-将hexo上传到github-1"><a href="#6-将hexo上传到github-1" class="headerlink" title="6.将hexo上传到github"></a>6.将hexo上传到github</h2><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，<strong>打开博客根目录下的_config.yml文件</strong>，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。<br><strong>修改配置:</strong></p><pre><code>deploy:  type: git  repository: https://github.com/shw2018/shw2018.github.io  branch: master</code></pre><p>  repository填自己的github项目地址</p><p>然后在博客目录下,安装deploy-git,这样才能同步到github的远程仓库上<br>输入: </p><pre><code>npm install hexo-deployer-git --save</code></pre><p>最后输入: </p><pre><code>hexo clean //(清理public文件) hexo generate //(生成静态页面)hexo deploy //(上传到github)</code></pre><p>到这里,hexo基本搭建就完成了</p><hr><h2 id="7-发表博客"><a href="#7-发表博客" class="headerlink" title="7.发表博客"></a>7.发表博客</h2><p>在博客根目录下的source文件夹创建.md后缀的文件,windows建议下载一个<a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkDownPad</a>,用MarkdownPad写博客内容即可.</p><p><a href="https://ricado-xv.github.io/2020/03/09/markdown-yu-fa/">Markdown简明语法</a></p><h1 id="超级感谢参考博客-洪卫の博客"><a href="#超级感谢参考博客-洪卫の博客" class="headerlink" title="超级感谢参考博客:洪卫の博客"></a>超级感谢参考博客:<a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-4" target="_blank" rel="noopener">洪卫の博客</a></h1><h1 id="廖雪峰老师的Git教程写的非常好，大家可以看一下。Git教程"><a href="#廖雪峰老师的Git教程写的非常好，大家可以看一下。Git教程" class="headerlink" title="廖雪峰老师的Git教程写的非常好，大家可以看一下。Git教程"></a>廖雪峰老师的Git教程写的非常好，大家可以看一下。<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">Git教程</a></h1><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> -hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举类型的秘密</title>
      <link href="/2020/03/17/mei-ju-lei-xing-de-mi-mi/"/>
      <url>/2020/03/17/mei-ju-lei-xing-de-mi-mi/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举类型的好处"><a href="#枚举类型的好处" class="headerlink" title="枚举类型的好处"></a>枚举类型的好处</h1><hr><h3 id="1-约束性好-减少错误"><a href="#1-约束性好-减少错误" class="headerlink" title="1.约束性好,减少错误:"></a>1.约束性好,减少错误:</h3><h3 id="以B站上传视频为例-视频一般有三个状态-草稿-审核-发布-可以定义位静态常量"><a href="#以B站上传视频为例-视频一般有三个状态-草稿-审核-发布-可以定义位静态常量" class="headerlink" title="以B站上传视频为例,视频一般有三个状态:草稿,审核,发布.可以定义位静态常量:"></a>以B站上传视频为例,视频一般有三个状态:草稿,审核,发布.可以定义位静态常量:</h3><h5 id="不用枚举类型"><a href="#不用枚举类型" class="headerlink" title="不用枚举类型:"></a>不用枚举类型:</h5><pre><code>  public class VideoStatus{  public static final int Draft=1;//草稿  public static final int Review=2;//审核  public static final int Published=3;//发表} void judgeVideoStatus(int status){//判断状态的函数,由于没  有类型上的约束,任意一个int值都可以,不会报错  ...}</code></pre><h5 id="用枚举类型"><a href="#用枚举类型" class="headerlink" title="用枚举类型:"></a>用枚举类型:</h5><pre><code>public enum VideoStatus{  Draft,Review,Published}void judgeVideoStatus(VideoStatus status){//这里传入参数的约束很明确,不容易出错  ...}</code></pre><hr><h3 id="2-枚举类型通常的方法"><a href="#2-枚举类型通常的方法" class="headerlink" title="2.枚举类型通常的方法:"></a>2.枚举类型通常的方法:</h3><h5 id="以后台管理系统为例-角色一般是固定的-有系统管理员-订单管理员-普通用户"><a href="#以后台管理系统为例-角色一般是固定的-有系统管理员-订单管理员-普通用户" class="headerlink" title="以后台管理系统为例,角色一般是固定的,有系统管理员,订单管理员,普通用户."></a>以后台管理系统为例,角色一般是固定的,有系统管理员,订单管理员,普通用户.</h5><pre><code>public enum UserRole{  ROLE_ROOT_ADMIN,//系统管理员  ROLE_ORDER_ADMIN,//订单管理员  ROLE_NORMAL //普通用户}UserRole role1=UserRole.ROLE_ROOT_ADMIN;UserRole role2=UserRole.ROLE_ORDER_ADMIN;UserRole role3=UserRole.ROLE_NORMAL;for(UserRole role : UserRole.values() ){  System.out.printIn(role);//打印出各个role的值}//ordinal()方法: 返回枚举常量的序数,注意从0开始System.out.printIn(role1.ordinal() );//打印出数组编号,这个是0System.out.printIn(role2.ordinal() );//打印出数组编号,这个是1System.out.printIn(role3.ordinal() );//打印出数组编号,这个是2   //compareTo()方法: 枚举常量顺序的比较System.out.printIn(role1.compareTo(role2) );//打印-1System.out.printIn(role2.compareTo(role3) );//打印-1System.out.printIn(role1.compareTo(role3) );//打印-2//name()方法: 获取枚举常量的名称System.out.printIn(role1.name() );//打印ROLE_ROOT_ADMINSystem.out.printIn(role2.name() );//打印ROLE_ORDER_ADMINSystem.out.printIn(role3.name() );//打印ROLE_NORMAL//valueOf()方法: 返回指定名称的枚举常量System.out.printIn(UserRole.valueOf("ROLE_ROOT_ADMIN") );//打印role1System.out.printIn(UserRole.valueOf("ROLE_ORDER_ADMIN") );//打印role2System.out.printIn(UserRole.valueOf("ROLE_NORMAL") );//打印role3</code></pre><h5 id="除此之外-枚举还可用于switch语句里"><a href="#除此之外-枚举还可用于switch语句里" class="headerlink" title="除此之外,枚举还可用于switch语句里"></a>除此之外,枚举还可用于switch语句里</h5><pre><code>switch(userRole){  case ROLE_NORMAL:     ...     break;  case ROLE_ORDER_ADMIN:     ...     break;  case ROLE_ROOT_ADMIN:     ...     break;}</code></pre><hr><h3 id="3-枚举类型的拓展性"><a href="#3-枚举类型的拓展性" class="headerlink" title="3.枚举类型的拓展性:"></a>3.枚举类型的拓展性:</h3><h5 id="例如在枚举里加入角色名-编码的对应关系-并且自定义一些属性-构造函数-甚至各种方法-和class一样"><a href="#例如在枚举里加入角色名-编码的对应关系-并且自定义一些属性-构造函数-甚至各种方法-和class一样" class="headerlink" title="例如在枚举里加入角色名-编码的对应关系,并且自定义一些属性,构造函数,甚至各种方法.和class一样."></a>例如在枚举里加入角色名-编码的对应关系,并且自定义一些属性,构造函数,甚至各种方法.和class一样.</h5><pre><code>  public enum UserRole{  ROLE_ROOT_ADMIN( "系统管理员",000000),  ROLE_ORDER_ADMIN( "订单管理员",100000),  ROLE_NORMAL("普通用户",200000),  ;  //自定义属性  private final String roleName;//角色名称  private final Integer roleCode;//角色编码  //自定义构造函数  UserRole( String roleName,Integer roleCode){     this.roleName=roleName;     this.roleCode=roleCode;  }  //自定义方法  public String getRoleName(){     return this.roleName;  }  public Integer getRoleCode(){     return this.roleCode;  }  public static Integer getRoleCodebyRoleName( String roleName){     for(UserRole enums: UserRole.values()){        if(enums.getRoleName.equals(roleName)){           return enums.getRoleCode;        }     }     return null;  }}</code></pre><hr><h3 id="4-枚举-接口"><a href="#4-枚举-接口" class="headerlink" title="4.枚举+接口:"></a>4.枚举+接口:</h3><h5 id="可以消灭if-else-增强代码的可读性"><a href="#可以消灭if-else-增强代码的可读性" class="headerlink" title="可以消灭if/else,增强代码的可读性"></a>可以消灭if/else,增强代码的可读性</h5><pre><code>//定义一个公用接口RoleOperation,表示不同角色的操作public interface RoleOperation{  String op();//表示某个角色可以做哪些op操作}//下面定义一个枚举类RoleEnum,用它实现RoleOperation接口public enum RoleEnum implements RoleOperation{  //系统管理员有A权限  ROLE_ROOT_ADMIN{     @override     public String op(){        return "ROLE_ROOT_ADMIN"+"has A permission";     }  },  //订单管理员有B权限  ROLE_ORDER_ADMIN{     @override     public String op(){        return "ROLE_ORDER_ADMIN"+"has B permission";     }  },  //普通用户有C权限  ROLE_NORMAL{     @override     public String op(){        return "ROLE_NORMAL"+"has C permission";     }  };}public class JudgeRole{  public String judge(String roleName){     return RoleEnum.valueOf(roleName).op();  }}</code></pre><hr><h3 id="5-枚举与设计模式"><a href="#5-枚举与设计模式" class="headerlink" title="5. 枚举与设计模式"></a>5. 枚举与设计模式</h3><h5 id="①-单例模式"><a href="#①-单例模式" class="headerlink" title="① 单例模式"></a>① 单例模式</h5><pre><code>public class Singleton{  //构造函数私有化,避免外部创建实例  private Singleton(){  }  //定义一个内部枚举  public enum SingletonEnum{     SEED;//唯一一个枚举对象     private Singleton singleton;     SingletonEnum(){        singleton=new Singleton();//这里才是真正的对象,实例化了     }     public Singleton getInstnce(){        return singleton;     }  }  //外漏对象的获取方法,这是外面获取实例的唯一入口  public static Singleton getInstnce(){     return SingletonEnum.SEED.getInstnce();//通过唯一的枚举对象完成  }</code></pre><p>   }</p><h5 id="②策略模式"><a href="#②策略模式" class="headerlink" title="②策略模式"></a>②策略模式</h5><h5 id="这里举例写一个加减乘除计算器"><a href="#这里举例写一个加减乘除计算器" class="headerlink" title="这里举例写一个加减乘除计算器"></a>这里举例写一个加减乘除计算器</h5><pre><code>public class Test{  public enum Calculator{     ADDITION{//加法        public Double execute(Double x,Double y){           return x+y;        }     },     SUBTRACTION{//减法        public Double execute(Double x,Double y){           return x-y;        }     },     MULTIPLICATION{//乘法        public Double execute(Double x,Double y){           return x*y;        }     },     DIVISION{//除法        public Double execute(Double x,Double y){           return x/y;        }     };     public abstract Double execute(Double x,Double y);//抽象方法,可以避免产生这个抽象类的实例化对象  }  public static void main(String[] args){     System.out.printIn(Calculator.ADDITION.execute(4.0,2.0));//打印6.0  }</code></pre><p>   }</p><hr><h3 id="6-专用于枚举的集合类"><a href="#6-专用于枚举的集合类" class="headerlink" title="6.专用于枚举的集合类"></a>6.专用于枚举的集合类</h3><h5 id="对应于HashMap和HashSet-枚举有专门的集合类-EnumSet和EnumMap"><a href="#对应于HashMap和HashSet-枚举有专门的集合类-EnumSet和EnumMap" class="headerlink" title="对应于HashMap和HashSet,枚举有专门的集合类:EnumSet和EnumMap"></a>对应于HashMap和HashSet,枚举有专门的集合类:EnumSet和EnumMap</h5><h5 id="以开头的枚举类型为例"><a href="#以开头的枚举类型为例" class="headerlink" title="以开头的枚举类型为例:"></a>以开头的枚举类型为例:</h5><pre><code>public enum UserRole{   ROLE_NORMAL,ROLE_ORDER_ADMIN,ROLE_ROOT_ADMIN}</code></pre><h5 id="①EnumSet"><a href="#①EnumSet" class="headerlink" title="①EnumSet"></a>①EnumSet</h5><h5 id="比如系统里来了一批人-查看他是不是枚举类型里的某个角色"><a href="#比如系统里来了一批人-查看他是不是枚举类型里的某个角色" class="headerlink" title="比如系统里来了一批人,查看他是不是枚举类型里的某个角色"></a>比如系统里来了一批人,查看他是不是枚举类型里的某个角色</h5><pre><code>//定义一个管理员角色的专属集合EnumSet&lt;UserRole&gt; userRoleForAdmin  =EnumSet.of(     UserRole.ROLE_ORDER_ADMIN,     UserRole.ROLE_ROOT_ADMIN  );//判断某个进来的用户是不是管理员Boolean isAdmin(User user){  if( userRoles.contains(user.getUserRole()))//java.lang.String里的函数,返回主体是否包含了括号里的参数  /*String s='It's great to see you here.'   Boolean c=s.contains(".")*/     return true;  return false; }</code></pre><h5 id="②EnumMap"><a href="#②EnumMap" class="headerlink" title="②EnumMap"></a>②EnumMap</h5><h5 id="EnumMap用来存放枚举类型为key的Map类型"><a href="#EnumMap用来存放枚举类型为key的Map类型" class="headerlink" title="EnumMap用来存放枚举类型为key的Map类型"></a>EnumMap用来存放枚举类型为key的Map类型</h5><h5 id="比如-系统里来了一批人-我们统计不同的角色到底有多少人"><a href="#比如-系统里来了一批人-我们统计不同的角色到底有多少人" class="headerlink" title="比如,系统里来了一批人,我们统计不同的角色到底有多少人:"></a>比如,系统里来了一批人,我们统计不同的角色到底有多少人:</h5><pre><code>Map&lt;UserRole,Integer&gt; userStatisticMap=new EnumMap&lt;&gt;(UserRole.class);for(User user : userList){  Integer num=userStatisticMap.get(user.getUserRole() );  if(null!=num){     userStatisticMap.put(user.getUserRole(),num+1);  }else{     userStatisticMap.put(user.getUserRole(),1);  }}</code></pre><h1 id="感谢微信公众号CodeSheep"><a href="#感谢微信公众号CodeSheep" class="headerlink" title="感谢微信公众号CodeSheep"></a>感谢微信公众号CodeSheep</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown简明语法</title>
      <link href="/2020/03/09/markdown-yu-fa/"/>
      <url>/2020/03/09/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-blog搭建教程-clik-here"><a href="#hexo-blog搭建教程-clik-here" class="headerlink" title="hexo blog搭建教程(clik here)"></a>hexo blog搭建教程<a href="https://www.itrhx.com/2018/08/15/A02-hexo-blog/" target="_blank" rel="noopener">(clik here)</a></h1><p><strong>一个人来到田纳西</strong></p><p><em>毫无疑问</em></p><p>*我做的馅饼 </p><p>是全天下*</p><p><em>最好吃的</em></p><hr><blockquote><p>引用</p><blockquote><p>引用中的引用</p></blockquote></blockquote><hr><h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><p>#一级标题<br>##二级标题<br>###三级标题<br>####四级标题<br>#####五级标题<br>######六级标题</p><ul><li>无序列表</li></ul><ul><li>无序列表</li></ul><ul><li>无序列表</li></ul><ol><li>1.有序列表</li><li>2.有序列表</li><li>3.有序列表</li></ol><ul><li>嵌套列表<ul><li>嵌套列表<ul><li>嵌套列表</li></ul><ul><li>嵌套列表</li></ul></li></ul><ul><li>嵌套列表</li></ul></li></ul><hr><h2 id="参考来源-不如Blog"><a href="#参考来源-不如Blog" class="headerlink" title="参考来源: 不如Blog"></a>参考来源: <a href="http://bruce-sha.github.io" target="_blank" rel="noopener" title="不如的博客">不如Blog</a></h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png" alt="Github Mark" title="GitHub Mark"></h2><p><strong><em>Reference方式索引</em></strong><br><a href="ibruce.info/2013/11/26/markdown/">不如(markdown语法)</a></p><p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png" alt="Github Octocat"></p><hr><p><strong>自动链接</strong><br>(还是不如的blog)<br><a href="http://ibruce.info" target="_blank" rel="noopener">http://ibruce.info</a></p><hr><p><strong>代码:行内代码</strong></p><p>  val s = “hello Markdown”<br>  println( s )</p><p><strong>代码:段落代码</strong></p><pre><code>val s= "hello Markdown"println( s )&lt;!--注释--&gt;</code></pre><hr><p><strong>转义字符</strong></p><p>\</p><p>`</p><p>*</p><p>_</p><p>{拉拉拉}</p><p>[啦啦啦]</p><p>(啦啦啦)</p><p>#</p><p>+</p><p>-</p><p>.</p><p>!</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code>文本可以直接用html标签但是前后要加空行</code></pre><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>|| <em>year</em> || <em>Temperature (low)</em> || <em>Temperature(high)</em> ||</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> -Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成-定点数的加减乘除</title>
      <link href="/2020/03/09/ji-suan-ji-zu-cheng-ding-dian-shu-yun-suan/"/>
      <url>/2020/03/09/ji-suan-ji-zu-cheng-ding-dian-shu-yun-suan/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小代码:&lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;td&gt; </span><br><span class="line">异或: \bigoplus</span><br><span class="line">不等号: \not =</span><br></pre></td></tr></tbody></table></figure><h1 id="一-、定点数加减运算"><a href="#一-、定点数加减运算" class="headerlink" title="一 、定点数加减运算"></a>一 、定点数加减运算</h1><h2 id="1-补码"><a href="#1-补码" class="headerlink" title="1. 补码"></a>1. 补码</h2><h2 id="2-BCD码"><a href="#2-BCD码" class="headerlink" title="2. BCD码"></a>2. BCD码</h2><h2 id="3-移码"><a href="#3-移码" class="headerlink" title="3. 移码"></a>3. 移码</h2><hr><h3 id="1-补码-最常用"><a href="#1-补码-最常用" class="headerlink" title="1. 补码(最常用)"></a>1. 补码(最常用)</h3><ul><li>$[X+Y]_补$=$[X]_补+[Y]_补$</li><li>$[X-Y]_补$=$[X]_补+[-Y]_补$<ul><li>$[-Y]<em>补$=$[[Y]_补]</em>{求补}$</li></ul></li></ul><p><strong>规则:</strong></p><ol><li>所有数用补码表示</li><li>符号位也参加运算</li><li>补充:求补运算简单算法:<ul><li>对于负数:是所有位取反,末位+1.</li><li>对于正数来说,原码就是补码</li></ul></li><li>运算结果也是补码</li></ol><p><strong>问题:</strong> 溢出问题</p><ol><li>异号相加不会溢出</li><li>同号相加才可能溢出</li></ol><p><strong>解决:</strong> 溢出判定</p><p>(我第一次看的时候不知道这有啥用,后来发现,溢出判定实际上是设计数字电路的时候的逻辑)</p><ol><li>双符号位: 00表示正,11表示负: <em>符号位异或,结果是1,则发生了溢出.</em></li><li>进位判决:最高数值位向符号位的进位记为$C_{n-1}$,符号位的进位记为$C_n$.<em>二者异或,结果是1,则发生溢出.</em></li><li>运算符异或进位符:运算结果的符号位结果记为$S_F$,进位标志记为$C_F$,<em>二者异或,结果是1则发生溢出.</em></li><li>根据运算前后的符号位判别.</li></ol><h3 id="2-BCD码-不常用"><a href="#2-BCD码-不常用" class="headerlink" title="2. BCD码(不常用)"></a>2. BCD码(不常用)</h3><p>核心是4位的二进制数是模16运算,BCD码不是.</p><p>以<strong>8421BCD</strong>为例,用<em>4位二进制数</em>,表示<em>1位十进制数</em> .</p><p><strong>矫正:</strong><br>二进制数的结果大于9时,则需要进位,并且-06H作为矫正(因为模16比模10多了6)</p><h3 id="3-移码-和补码差不多"><a href="#3-移码-和补码差不多" class="headerlink" title="3. 移码(和补码差不多)"></a>3. 移码(和补码差不多)</h3><p><strong>规则:</strong></p><ol><li>先对两移码求和差,最后把<strong>结果的符号位取反</strong>作为修正.</li><li>eg: $[57-35]<em>移$=<strong><em>-</em></strong>($[57]_移+[[35]_移]</em>{求补}$)</li></ol><hr><h1 id="二、定点数乘法运算"><a href="#二、定点数乘法运算" class="headerlink" title="二、定点数乘法运算"></a>二、定点数乘法运算</h1><h2 id="1-原码一位"><a href="#1-原码一位" class="headerlink" title="1.原码一位"></a>1.原码一位</h2><h2 id="2-原码二位"><a href="#2-原码二位" class="headerlink" title="2.原码二位"></a>2.原码二位</h2><h2 id="3-补码一位-校正法-amp-Booth法"><a href="#3-补码一位-校正法-amp-Booth法" class="headerlink" title="3.补码一位(校正法&amp;Booth法)"></a>3.补码一位(校正法&amp;Booth法)</h2><h2 id="4-补码二位"><a href="#4-补码二位" class="headerlink" title="4.补码二位"></a>4.补码二位</h2><h3 id="1-原码一位-1"><a href="#1-原码一位-1" class="headerlink" title="1.原码一位"></a>1.原码一位</h3><p><strong>规则:</strong></p><ol><li>乘积的符号位是被乘数和乘数的符号位的异或.</li><li>乘积的绝对值是被惩处的绝对值和乘数的绝对值之积.</li></ol><p><strong>即:[X]原×[Y]原=($X_0\bigoplus Y_0$) ($\mid X \mid \times \mid Y \mid$)</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是代码(我自己学markdown记的,不重要)</span><br><span class="line">($X_0\bigoplus Y_0$) ($\mid X \mid \times \mid Y \mid$)</span><br></pre></td></tr></tbody></table></figure><p>其中$X_0 ,Y_0$是符号位</p><p><strong>eg.$0.1101 \times1.1011$</strong></p><table>   <tbody><tr>      <th>(缓冲区)</th>      <th>D</th>      <th colspan="2">A(最后一个是末位)</th>      <th>原因和操作</th>   </tr>   <tr>      <td>0</td>      <td>0 0 0 0 </td>      <td>1 0 1</td>      <td>1</td>      <td>末位是1,下一行+x</td>   </tr>   <tr>      <td>0</td>      <td>1 1 0 1 </td>      <td>    </td>      <td> </td>      <td>+x</td>   </tr>   <tr>   <td>0</td>      <td>1 1 0 1 </td>      <td>1 0 1</td>      <td>1</td>      <td></td>    </tr>    <tr>   <td>0</td>      <td>0 1 1 0 </td>      <td>1 1 0</td>      <td>1</td>      <td>整体右移一位,末位是1,下一行+x</td>    </tr>       <tr>      <td>0</td>      <td>1 1 0 1 </td>      <td></td>      <td></td>      <td>+x</td>    </tr>    <tr>      <td>1</td>      <td>0 0 1 1 </td>      <td>1 1 0</td>      <td>1</td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>1 0 0 1 </td>      <td>1 1 1</td>      <td>0</td>      <td>右移一位,末位是0,下一行+0</td>    </tr>     <tr>      <td>0</td>      <td>0 0 0 0  </td>      <td></td>      <td></td>      <td>+0</td>    </tr>    <tr>      <td>0</td>      <td>1 0 0 1  </td>      <td>1 1 1</td>      <td>0</td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>0 1 0 0  </td>      <td>1 1 1</td>      <td>1</td>      <td>右移一位,末位是1,下一行+x</td>    </tr>    <tr>      <td>0</td>      <td>1 1 0 1  </td>      <td></td>      <td></td>      <td>+x</td>    </tr>    <tr>      <td>1</td>      <td>0 0 0 1  </td>      <td>1 1 1</td>      <td>1</td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>1 0 0 0   </td>      <td>1 1 1</td>      <td>1</td>      <td>右移一次</td>    </tr></tbody></table><p><strong>结果:</strong> $0.1101 \times1.1011$=1.1000 1111</p><p><strong>特点:</strong> </p><ol><li>被乘数有几位,运算过程就右移几次,每次右移的时候,数值位的首位补0</li><li>符号位不参与运算,运算前先$\bigoplus$,决定结果的符号</li></ol><h3 id="2-原码二位-1"><a href="#2-原码二位-1" class="headerlink" title="2.原码二位"></a>2.原码二位</h3><p><strong>规则:</strong></p><ol><li><p>原理和原码一位一样,只是从电路层面简化了运算步骤</p></li><li><p>记被乘数的最后两位分别为$A_n A_{n-1}$</p></li><li><p>记$C=A_n\bigoplus A_{n-1}$,</p><p>若$C=0$,则下一步操作是-X,</p><p>若$C=1$,则下一步操作的+2X</p></li></ol><p><strong>eg.</strong> X= +0.100 111, Y= -0.100 111 求X$\times$Y</p><p><strong>准备工作:</strong> </p><p>$-X=[X]_补$=1.011 001(第一位是符号位)</p><p>$2X$=01.001 110(第一位是符号位)</p><table> <tbody><tr>  <th>符号位</th>  <th>D</th>  <th colspan="2">A | An-1 An </th>  <th>C=An异或An-1</th>  <th>操作</th> </tr>   <tr>      <td>0 0 0</td>      <td>0 0 0 0 0 0</td>      <td>1 0 0 1</td>      <td>1 1</td>      <td>0</td>      <td>C=0,下一行-x</td>   </tr>   <tr>      <td>1 1 1</td>      <td>0 1 1 0 0 1</td>      <td></td>      <td></td>      <td></td>      <td>-x(+x的补码)</td>   </tr>   <tr>      <td>1 1 1</td>      <td>0 1 1 0 0 1</td>      <td>1 0 0 1</td>      <td>1 1</td>      <td></td>      <td></td>   </tr>   <tr>      <td>1 1 1</td>      <td>1 1 0 1 1 0</td>      <td>0 1 1 0</td>      <td>0 1</td>      <td>1</td>      <td>右移两位,C=1,下一行+2x</td>   </tr>   <tr>      <td>0 0 1</td>      <td>0 0 1 1 1 0</td>      <td></td>      <td></td>      <td></td>      <td>+2x</td>   </tr>   <tr>      <td>0 0 1</td>      <td>0 0 0 1 0 0</td>      <td>0 1 1 0</td>      <td>0 1</td>      <td></td>      <td></td>   </tr>   <tr>      <td>0 0 0</td>      <td>0 1 0 0 0 1</td>      <td>0 0 0 1</td>      <td>1 0</td>      <td>1</td>      <td>右移两位,C=1,下一行+2x</td>   </tr>   <tr>      <td>0 0 1</td>      <td>0 0 1 1 1 0 </td>      <td></td>      <td></td>      <td></td>      <td>+2x</td>   </tr>   <tr>      <td>0 0 1</td>      <td>0 1 1 1 1 1 </td>      <td>0 0 0 1</td>      <td>1 0</td>      <td></td>      <td></td>   </tr>   <tr>      <td>0 0 0</td>      <td>0 1 0 1 1 1 </td>      <td>1 1 0 0</td>      <td>0 1</td>      <td></td>      <td>右移两位,</td>   </tr></tbody></table><p><strong>结果:</strong><br>+0.100 111$\times$-0.100 111=1.0101 1111 0001</p><p>其中第一位是符号位,是由乘数和被乘数异或得到的</p><p><strong>特点:</strong>(和原码一位区别很大)</p><p><strong>移位的时候,缓存区的数字不变,即缓存区原本的数字是什么,就补什么</strong></p><h3 id="3-补码一位"><a href="#3-补码一位" class="headerlink" title="3.补码一位"></a>3.补码一位</h3><h4 id="1-校正法"><a href="#1-校正法" class="headerlink" title="1.校正法"></a>1.校正法</h4><p><strong>规则:</strong><br>和原码类似,但是最后一位要校正.<br>X$\times$Y,<strong>若Y的符号位是1,则运算结果要加上$-[X]_补$</strong></p><p><strong>eg.</strong><br>X=-0.1101,Y=0.1011<br><strong>准备工作:</strong>$[X]_补$=1.0011,<br>$[Y]_补$=0.1011<br>(求补运算的时候符号位不变,第一位是符号位)</p><table> <tbody><tr>  <th>符号</th>  <th>D</th>  <th>A</th>  <th>操作</th> </tr>     <tr>      <td>0 0</td>      <td>0 0 0 0</td>      <td>1 0 1 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td></td>      <td>+X补</td>     </tr>          <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td>1 0 1 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>1 0 0 1</td>      <td>1 1 0 1</td>      <td>右移一位</td>     </tr>     <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td></td>      <td>+X补</td>     </tr>     <tr>      <td>1 0</td>      <td>1 1 0 0</td>      <td>1 1 0 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>0 1 1 0</td>      <td>0 1 1 0</td>      <td>右移一位</td>     </tr>     <tr>      <td>0 0</td>      <td>0 0 0 0</td>      <td></td>      <td>+0</td>     </tr>     <tr>      <td>1 1</td>      <td>0 1 1 0</td>      <td>0 1 1 0</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>1 0 1 1</td>      <td>0 0 1 1</td>      <td>右移一位</td>     </tr>     <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td></td>      <td>+X补</td>     </tr>     <tr>      <td>1 0</td>      <td>1 1 1 0</td>      <td>0 0 1 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>0 1 1 1</td>      <td>0 0 0 1</td>      <td>右移一位</td>     </tr></tbody></table><p><strong>结果:</strong>$[X\times Y]_补$=1.0111 0001</p><p><strong>特点:</strong></p><ol><li>右移补位的时候,首位是啥就补啥.</li><li>+0的时候,0的符号位也是0.</li><li>符号位是一起算出来的,不是两个数的符号位异或直接得到的.</li><li>起始的符号位按00算,不论它本身是正是负.</li><li>最后记得加校正!!!第4点的时候,本身的符号位就是00的话,记得-$[X]_补$</li></ol><p><strong>eg2.</strong></p><p>X=-0.1101,Y=-0.1011</p><p><strong>准备工作:</strong>$[X]_补$=1.0011,<br>$[Y]_补$=0.0101<br>(求补运算的时候符号位不变,第一位是符号位)</p><table> <tbody><tr>  <th>符号</th>  <th>D</th>  <th>A</th>  <th>操作</th> </tr>     <tr>      <td>0 0</td>      <td>0 0 0 0</td>      <td>0 1 0 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td></td>      <td>+X补</td>     </tr>          <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td>0 1 0 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>1 0 0 1</td>      <td>1 0 1 0</td>      <td>右移一位</td>     </tr>     <tr>      <td>0 0</td>      <td>0 0 0 0</td>      <td></td>      <td>+0</td>     </tr>     <tr>      <td>1 1</td>      <td>1 0 0 1</td>      <td>1 0 1 0</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>1 1 0 0</td>      <td>1 1 0 1</td>      <td>右移一位</td>     </tr>     <tr>      <td>1 1</td>      <td>0 0 1 1</td>      <td></td>      <td>+X补</td>     </tr>     <tr>      <td>1 0</td>      <td>1 1 1 1</td>      <td>1 1 0 1</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>0 1 1 1</td>      <td>1 1 1 0</td>      <td>右移一位</td>     </tr>     <tr>      <td>0 0</td>      <td>0 0 0 0</td>      <td></td>      <td>+0</td>     </tr>     <tr>      <td>1 1</td>      <td>0 1 1 1</td>      <td>1 1 1 0</td>      <td></td>     </tr>     <tr>      <td>1 1</td>      <td>1 0 1 1</td>      <td>1 1 1 1</td>      <td>右移一位</td>     </tr>     <tr>      <td>0 0</td>      <td>1 1 0 1</td>      <td></td>      <td>+[-X]补</td>     </tr>     <tr>      <td>0 0</td>      <td>1 0 0 0</td>      <td>1 1 1 1</td>      <td>结果</td>     </tr></tbody></table><p><strong>结果:</strong>$[X\times Y]_补$=0.10001111</p><h4 id="2-Booth法"><a href="#2-Booth法" class="headerlink" title="2.Booth法"></a>2.Booth法</h4><p><strong>规则:</strong> 和原码二位极度相似,但是符号位直接参与运算</p><p>设被乘数$Y$的最后一位是$Y_n$,补一位$A_0$(初值是0),$C=A_0-Y_{n}$</p><table>   <tbody><tr>      <th>Yn</th>      <th>A0</th>      <th>C=A0-Yn</th>      <th>操作</th>   </tr>      <tr>         <td>0</td>         <td>0</td>         <td>0</td>         <td>+0,右移一次</td>      </tr>      <tr>         <td>0</td>         <td>1</td>         <td>1</td>         <td>+[X]补,右移一次</td>      </tr>      <tr>         <td>1</td>         <td>0</td>         <td>-1</td>         <td>+[-X]补,右移一次</td>      </tr>      <tr>         <td>1</td>         <td>1</td>         <td>0</td>         <td>+0,右移一次</td>      </tr></tbody></table><p><strong>eg.</strong> X=0.1010,Y=-0.1101利用Booth法补码一位乘法,求乘积.</p><p><strong>准备工作:</strong>$[X]_补$=0.1010,$[-X]_补$=1.0110,$[Y]_补$=1.0011</p><table>   <tbody><tr>      <th>缓存区</th>      <th>D</th>      <th>A</th>      <th>A0</th>      <th>操作</th>   </tr>      <tr>         <td>0 0</td>         <td>0 0 0 0</td>         <td>1 0 0 1 1</td>         <td>0</td>         <td></td>        </tr>      <tr>         <td>1 1</td>         <td>0 1 1 0</td>         <td></td>         <td></td>         <td>+[-X]补</td>        </tr>      <tr>         <td>1 1</td>         <td>0 1 1 0</td>         <td>1 0 0 1 1</td>         <td>0</td>         <td></td>        </tr>      <tr>         <td>1 1</td>         <td>1 0 1 1</td>         <td>0 1 0 0 1</td>         <td>1</td>         <td>右移一位</td>        </tr>      <tr>         <td>0 0</td>         <td>0 0 0 0</td>         <td></td>         <td></td>         <td>+0</td>        </tr>      <tr>         <td>1 1</td>         <td>1 0 1 1</td>         <td>0 1 0 0 1</td>         <td>1</td>         <td></td>        </tr>      <tr>         <td>1 1</td>         <td>1 1 0 1</td>         <td>1 0 1 0 0</td>         <td>1</td>         <td>右移一位</td>        </tr>      <tr>         <td>0 0</td>         <td>1 0 1 0</td>         <td></td>         <td></td>         <td>+[X]补</td>        </tr>      <tr>         <td>0 0</td>         <td>0 1 1 1</td>         <td>1 0 1 0 0</td>         <td>1</td>         <td></td>        </tr>      <tr>         <td>0 0</td>         <td>0 0 1 1</td>         <td>1 1 0 1 0</td>         <td>0</td>         <td>右移一位</td>        </tr>      <tr>         <td>0 0</td>         <td>0 0 0 0</td>         <td></td>         <td></td>         <td>+0</td>        </tr>      <tr>         <td>0 0</td>         <td>0 0 1 1</td>         <td>1 1 0 1 0</td>         <td>0</td>         <td></td>        </tr>      <tr>         <td>0 0</td>         <td>0 0 0 1</td>         <td>1 1 1 0 1</td>         <td>0</td>         <td>右移一位</td>        </tr>      <tr>         <td>1 1</td>         <td>0 1 1 0</td>         <td></td>         <td></td>         <td>+[-X]补</td>        </tr>      <tr>         <td>1 1</td>         <td>0 1 1 1</td>         <td>1 1 1 0 1</td>         <td>0</td>         <td></td>        </tr>      <tr>         <td>1 1</td>         <td>1 0 1 1 </td>         <td>1 1 1 1 0 </td>         <td>1</td>         <td>右移一位</td>        </tr></tbody></table><p><strong>结果:</strong> $[X\times Y]_补$=1.0111 1110</p><p><strong>特点:</strong> 缓存区不算做结果的符号位,补的$A_0$不算结果,相当于另一个缓存区</p><h3 id="4-补码二位-1"><a href="#4-补码二位-1" class="headerlink" title="4.补码二位"></a>4.补码二位</h3><p><strong>规则:</strong> </p><ol><li>和补码一位的Booth法类似,原理相同,只是在数字电路层面做了优化.<strong><em>记得补前后的缓存区 !</em></strong></li><li>当乘数(包括符号位)位数是偶数n时,右移次数位n/2次,最后一次只移1位(技巧,当补码一位的Booth法考虑)</li></ol><table>   <tbody><tr>      <th>Y(i-2) Y(i-1) Y(i)</th>      <th>Y(i)+Y(i-1)-2Y(i-2)</th>      <th>操作</th>   </tr>      <tr>         <th>0 0 0</th>         <th>0</th>         <th>+0, 右移2位</th>         </tr>      <tr>         <th>0 0 1</th>         <th>1</th>         <th>+[X]补, 右移2位</th>         </tr>      <tr>         <th>0 1 0</th>         <th>1</th>         <th>+[X]补, 右移2位</th>         </tr>      <tr>         <th>0 1 1</th>         <th>2</th>         <th>+2[X]补, 右移2位</th>         </tr>      <tr>         <th>1 0 0</th>         <th>-2</th>         <th>+2[-X]补, 右移2位</th>         </tr>      <tr>         <th>1 0 1</th>         <th>-1</th>         <th>+[-X]补, 右移2位</th>         </tr>      <tr>         <th>1 1 0</th>         <th>-1</th>         <th>+[-X]补, 右移2位</th>         </tr>      <tr>         <th>1 1 1</th>         <th>0</th>         <th>+0, 右移2位</th>         </tr></tbody></table><p><strong>eg.</strong> 已知X=-0.1101,Y=-0.1011,试用补码二位乘法求积.<br><strong>准备工作:</strong> [X]补=1.0011,[Y]补=1.0101,为了不溢出,采用3符号位.<br>[X]补=111.0011 2[X]补=110.0110 [-X]补=000.1101 2[-X]补=001.1010.同时[Y]补=11.0101</p><table>   <tbody><tr>      <th>前缓存区</th>      <th>D</th>      <th>A</th>      <th>后缓存区</th>      <th>操作</th>   </tr>      <tr>         <td>0 0 0</td>         <td>0 0 0 0</td>         <td>1 1 0 1 0 1</td>         <td>0</td>         <td></td>      </tr>      <tr>         <td>1 1 1</td>         <td>0 0 1 1</td>         <td></td>         <td></td>         <td>+[X]补</td>      </tr>      <tr>         <td>1 1 1</td>         <td>0 0 1 1</td>         <td>1 1 0 1 0 1</td>         <td></td>         <td></td>      </tr>      <tr>         <td>1 1 1</td>         <td>1 1 0 0</td>         <td>1 1 1 1 0 1</td>         <td>0</td>         <td>右移2位</td>      </tr>      <tr>         <td>1 1 1</td>         <td>0 0 1 1</td>         <td></td>         <td></td>         <td>+[X]补</td>      </tr>      <tr>         <td>1 1 0</td>         <td>1 1 1 1</td>         <td>1 1 1 1 0 1</td>         <td>0</td>         <td></td>      </tr>      <tr>         <td>1 1 1</td>         <td>1 0 1 1</td>         <td>1 1 1 1 1 1</td>         <td>0</td>         <td>右移2位</td>      </tr>      <tr>         <td>0 0 0</td>         <td>1 1 0 1</td>         <td></td>         <td></td>         <td>+[-X]补</td>      </tr>      <tr>         <td>0 0 0</td>         <td>1 0 0 0</td>         <td>1 1 1 1 1 1 </td>         <td>0</td>         <td></td>      </tr></tbody></table><p><strong>结果:</strong>[X $\cdot$ Y]补=0.1000 1111</p><hr><h1 id="三、定点数除法运算"><a href="#三、定点数除法运算" class="headerlink" title="三、定点数除法运算"></a>三、定点数除法运算</h1><h2 id="1-原码"><a href="#1-原码" class="headerlink" title="1.原码"></a>1.原码</h2><h2 id="2-恢复余数法"><a href="#2-恢复余数法" class="headerlink" title="2.恢复余数法"></a>2.恢复余数法</h2><h2 id="3-加减交替法"><a href="#3-加减交替法" class="headerlink" title="3.加减交替法"></a>3.加减交替法</h2><h3 id="1-原码-1"><a href="#1-原码-1" class="headerlink" title="1.原码"></a>1.原码</h3><p><strong>规则:</strong> </p><ol><li><p>除数$\not ={0}$ ,</p><p>纯小数时,|被除数|&lt;|除数|;</p><p>纯整数时,|被除数|&gt;|除数|.</p></li><li><p>和原码乘法类似,也是符号和绝对值分开处理.<br>(乘法是逐次加乘数,除法是逐次减除数)</p></li></ol><h3 id="2-恢复余数法-1"><a href="#2-恢复余数法-1" class="headerlink" title="2.恢复余数法"></a>2.恢复余数法</h3><p><strong>规则:</strong></p><p>这是为了计算机的运算,根据原码的除法设计的算法,因为计算机只有运算后才知道该商0还是商1,<strong>所以当商了0的时候,应该把减掉的除数加回来.</strong> 其他的和原码运算一样.</p><p><strong>eg.</strong> 被除数X=-0.1000 1011<br>,除数Y=0.1110,用原码恢复余数法,求商和余数.</p><p><strong>准备工作:</strong> 满足|X|&lt;|Y|,|Y|$\not ={0}$.<br>商符号是1$\bigoplus$ 0=1,<br>|X|原=1.1000 1011<br>|Y|原=0.1110</p><table>   <tbody><tr>      <th>缓冲区</th>      <th>被除数(余数)</th>      <th>操作</th>      <th>商</th>   </tr>   <tr>      <td>0 0</td>      <td>1 0 0 0 1 0 1 1</td>      <td></td>      <td></td>   </tr>   <tr>      <td>0 1</td>      <td>0 0 0 1 0 1 1 </td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0 </td>      <td>-Y=+|-Y|补</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>0 0 1 1 0 1 1 </td>      <td>缓冲区结果是00,够减,商1</td>      <td>1</td>   </tr>   <tr>      <td>0 0</td>      <td>0 1 1 0 1 1 </td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0  </td>      <td>-|Y|</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>1 0 0 0 1 1 </td>      <td>缓冲区结果是11,不够减,商0</td>      <td>1 0</td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 1 0 </td>      <td>+|Y|</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>0 1 1 0 1 1 </td>      <td>恢复余数</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 0 1 1 </td>      <td>左移一位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0</td>      <td>-|Y|</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>1 1 1 1 1</td>      <td>商0</td>      <td>1 0 0</td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 1 0</td>      <td>+|Y|</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 0 1 1</td>      <td>恢复余数</td>      <td></td>   </tr>   <tr>      <td>0 1</td>      <td>1 0 1 1</td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0</td>      <td>-|Y|</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 0 1</td>      <td>商1</td>      <td>1 0 0 1</td>   </tr></tbody></table><p><strong>余数小于被除数了,停止计算</strong><br><strong>结果是</strong>商1.1001 余0.1101</p><h3 id="3-加减交替法-1"><a href="#3-加减交替法-1" class="headerlink" title="3.加减交替法"></a>3.加减交替法</h3><p><strong>规则:</strong><br>和恢复余数法一样<br><strong>原理</strong>和恢复余数法完全一样,为了提高效率,商0时,本该恢复余数再-|Y|,改成直接+|Y|.因为左移相当于x2,商0后,如果不恢复余数的话,上次-|Y|的结果就是-2|Y|,所以这次运算直接+|Y|弥补,还是相当于这次-|Y|</p><p><strong>eg.</strong> 若X＝-0.10001011，Y＝0.1110 试利用原码加减交替<br>法求商及余数。</p><p><strong>准备工作:</strong> 符号位=1$\bigoplus$ 0=1,|X|原=1.1000 1011,|Y|原=0.1110.<br>除数Y!=0,|X|&lt;|Y|成立.</p><table>   <tbody><tr>      <th>缓冲区</th>      <th>被除数(余数)</th>      <th>操作</th>      <th>商</th>   </tr>   <tr>      <td>0 0</td>      <td>1 0 0 0 1 0 1 1</td>      <td></td>      <td></td>   </tr>   <tr>      <td>0 1</td>      <td>0 0 0 1 0 1 1 </td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0 </td>      <td>-Y=+|-Y|补</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>0 0 1 1 0 1 1 </td>      <td>缓冲区结果是00,够减,商1</td>      <td>1</td>   </tr>   <tr>      <td>0 0</td>      <td>0 1 1 0 1 1 </td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 1 0  </td>      <td>-|Y|</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>1 0 0 0 1 1 </td>      <td>缓冲区结果是11,不够减,商0</td>      <td>1 0</td>   </tr>   <tr>      <td>1 1</td>      <td>0 0 0 1 1 </td>      <td>左移一位</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 1 0</td>      <td>+|Y|</td>      <td></td>   </tr>   <tr>      <td>1 1</td>      <td>1 1 1 1 1</td>      <td>商0</td>      <td>1 0 0</td>   </tr>   <tr>      <td>1 1</td>      <td>1 1 1 1</td>      <td>左移1位</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 1 1 0</td>      <td>+|Y|</td>      <td></td>   </tr>   <tr>      <td>0 0</td>      <td>1 0 1 1</td>      <td>商1</td>      <td>1 1 0 1</td>   </tr></tbody></table><p><strong>结果和恢复余数法完全一样</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> -计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/08/hello-world/"/>
      <url>/2020/03/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
